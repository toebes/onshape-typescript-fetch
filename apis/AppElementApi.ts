/* tslint:disable */
/* eslint-disable */
/**
 * Onshape REST API
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn\'t used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.196.54436-927372740f35
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTAppElementBulkCreateInfo,
  BTAppElementBulkCreateParams,
  BTAppElementBulkModifyInfo,
  BTAppElementCommitTransactionParams,
  BTAppElementContentInfo,
  BTAppElementHistoryInfo,
  BTAppElementIdsInfo,
  BTAppElementModifyInfo,
  BTAppElementParams,
  BTAppElementReferenceInfo,
  BTAppElementReferenceParams,
  BTAppElementReferenceResolveInfo,
  BTAppElementReferencesResolveInfo,
  BTAppElementStartTransactionParams,
  BTAppElementTransactionsInfo,
  BTAppElementUpdateParams,
  BTDiffJsonResponse2725,
  BTGetJsonPaths1697,
  BTGetJsonPathsResponse1544,
  BTGetJsonResponse2137,
} from '../models';
import {
    BTAppElementBulkCreateInfoFromJSON,
    BTAppElementBulkCreateInfoToJSON,
    BTAppElementBulkCreateParamsFromJSON,
    BTAppElementBulkCreateParamsToJSON,
    BTAppElementBulkModifyInfoFromJSON,
    BTAppElementBulkModifyInfoToJSON,
    BTAppElementCommitTransactionParamsFromJSON,
    BTAppElementCommitTransactionParamsToJSON,
    BTAppElementContentInfoFromJSON,
    BTAppElementContentInfoToJSON,
    BTAppElementHistoryInfoFromJSON,
    BTAppElementHistoryInfoToJSON,
    BTAppElementIdsInfoFromJSON,
    BTAppElementIdsInfoToJSON,
    BTAppElementModifyInfoFromJSON,
    BTAppElementModifyInfoToJSON,
    BTAppElementParamsFromJSON,
    BTAppElementParamsToJSON,
    BTAppElementReferenceInfoFromJSON,
    BTAppElementReferenceInfoToJSON,
    BTAppElementReferenceParamsFromJSON,
    BTAppElementReferenceParamsToJSON,
    BTAppElementReferenceResolveInfoFromJSON,
    BTAppElementReferenceResolveInfoToJSON,
    BTAppElementReferencesResolveInfoFromJSON,
    BTAppElementReferencesResolveInfoToJSON,
    BTAppElementStartTransactionParamsFromJSON,
    BTAppElementStartTransactionParamsToJSON,
    BTAppElementTransactionsInfoFromJSON,
    BTAppElementTransactionsInfoToJSON,
    BTAppElementUpdateParamsFromJSON,
    BTAppElementUpdateParamsToJSON,
    BTDiffJsonResponse2725FromJSON,
    BTDiffJsonResponse2725ToJSON,
    BTGetJsonPaths1697FromJSON,
    BTGetJsonPaths1697ToJSON,
    BTGetJsonPathsResponse1544FromJSON,
    BTGetJsonPathsResponse1544ToJSON,
    BTGetJsonResponse2137FromJSON,
    BTGetJsonResponse2137ToJSON,
} from '../models';

export interface AbortTransactionRequest {
    did: string;
    eid: string;
    wid: string;
    tid: string;
    returnError?: boolean;
}

export interface BulkCreateElementRequest {
    did: string;
    wid: string;
    bTAppElementBulkCreateParams: BTAppElementBulkCreateParams;
    linkDocumentId?: string;
}

export interface CommitTransactionsRequest {
    did: string;
    wid: string;
    bTAppElementCommitTransactionParams: BTAppElementCommitTransactionParams;
    linkDocumentId?: string;
}

export interface CompareAppElementJsonRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    workspaceId?: string;
    versionId?: string;
    microversionId?: string;
    linkDocumentId?: string;
    jsonDifferenceFormat?: string;
}

export interface CreateElementRequest {
    did: string;
    wid: string;
    bTAppElementParams: BTAppElementParams;
    linkDocumentId?: string;
}

export interface CreateReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    bTAppElementReferenceParams: BTAppElementReferenceParams;
}

export interface DeleteAppElementContentRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    sid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
}

export interface DeleteAppElementContentBatchRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    subelementIds?: Array<string>;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
}

export interface DeleteBlobSubelementRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    transactionId?: string;
    changeId?: string;
}

export interface DeleteReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
}

export interface DownloadBlobSubelementRequest {
    did: string;
    vm: string;
    vmid: string;
    eid: string;
    bid: string;
    contentDisposition?: string;
    ifNoneMatch?: string;
    transactionId?: string;
    changeId?: string;
    linkDocumentId?: string;
}

export interface DownloadBlobSubelementWorkspaceRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    contentDisposition?: string;
    ifNoneMatch?: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetAppElementHistoryRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
}

export interface GetBlobSubelementIdsRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetElementTransactionsRequest {
    did: string;
    eid: string;
    wid: string;
}

export interface GetJsonRequest {
    did: string;
    wvm: GetJsonWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetJsonPathsRequest {
    did: string;
    wvm: GetJsonPathsWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
    bTGetJsonPaths1697?: BTGetJsonPaths1697;
}

export interface GetSubElementContentRequest {
    did: string;
    wvm: GetSubElementContentWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
    baseChangeId?: string;
    subelementId?: string;
}

export interface GetSubelementIdsRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    transactionId?: string;
    changeId?: string;
}

export interface ResolveAllElementReferencesRequest {
    did: string;
    wvm: ResolveAllElementReferencesWvmEnum;
    wvmid: string;
    linkDocumentId?: string;
    transactionId?: string;
    parentChangeId?: string;
    includeInternal?: boolean;
    referenceIds?: string;
    elementIds?: string;
    drawingsOnly?: boolean;
}

export interface ResolveReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    transactionId?: string;
    parentChangeId?: string;
    includeInternal?: boolean;
    linkDocumentId?: string;
}

export interface ResolveReferencesRequest {
    did: string;
    wvm: ResolveReferencesWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    parentChangeId?: string;
    includeInternal?: boolean;
    referenceIds?: string;
}

export interface StartTransactionRequest {
    did: string;
    eid: string;
    wid: string;
    bTAppElementStartTransactionParams: BTAppElementStartTransactionParams;
}

export interface UpdateAppElementRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    bTAppElementUpdateParams?: BTAppElementUpdateParams;
}

export interface UpdateReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    bTAppElementReferenceParams: BTAppElementReferenceParams;
}

export interface UploadBlobSubelementRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
    file?: Blob;
    fileContentLength?: number;
}

/**
 * 
 */
export class AppElementApi extends runtime.BaseAPI {

    /**
     * Deletes a microbranch (i.e., the branch with the microversion for the transaction).
     * Abort a transaction.
     */
    async abortTransactionRaw(requestParameters: AbortTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.tid === null || requestParameters.tid === undefined) {
            throw new runtime.RequiredError('tid','Required parameter requestParameters.tid was null or undefined when calling abortTransaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.returnError !== undefined) {
            queryParameters['returnError'] = requestParameters.returnError;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions/{tid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"tid"}}`, encodeURIComponent(String(requestParameters.tid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Deletes a microbranch (i.e., the branch with the microversion for the transaction).
     * Abort a transaction.
     */
    async abortTransaction(requestParameters: AbortTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.abortTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Call this faster API instead of creating multiple app elements one at a time or in parallel.
     * Create multiple empty application elements at once.
     */
    async bulkCreateElementRaw(requestParameters: BulkCreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementBulkCreateInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling bulkCreateElement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling bulkCreateElement.');
        }

        if (requestParameters.bTAppElementBulkCreateParams === null || requestParameters.bTAppElementBulkCreateParams === undefined) {
            throw new runtime.RequiredError('bTAppElementBulkCreateParams','Required parameter requestParameters.bTAppElementBulkCreateParams was null or undefined when calling bulkCreateElement.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/bulkcreate`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementBulkCreateParamsToJSON(requestParameters.bTAppElementBulkCreateParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementBulkCreateInfoFromJSON(jsonValue));
    }

    /**
     * Call this faster API instead of creating multiple app elements one at a time or in parallel.
     * Create multiple empty application elements at once.
     */
    async bulkCreateElement(requestParameters: BulkCreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementBulkCreateInfo> {
        const response = await this.bulkCreateElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If successful, all transactions will be committed to a single microversion. If the call raises an error, nothing will be committed.
     * Merge multiple transactions into one microversion.
     */
    async commitTransactionsRaw(requestParameters: CommitTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementBulkModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling commitTransactions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling commitTransactions.');
        }

        if (requestParameters.bTAppElementCommitTransactionParams === null || requestParameters.bTAppElementCommitTransactionParams === undefined) {
            throw new runtime.RequiredError('bTAppElementCommitTransactionParams','Required parameter requestParameters.bTAppElementCommitTransactionParams was null or undefined when calling commitTransactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementCommitTransactionParamsToJSON(requestParameters.bTAppElementCommitTransactionParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementBulkModifyInfoFromJSON(jsonValue));
    }

    /**
     * If successful, all transactions will be committed to a single microversion. If the call raises an error, nothing will be committed.
     * Merge multiple transactions into one microversion.
     */
    async commitTransactions(requestParameters: CommitTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementBulkModifyInfo> {
        const response = await this.commitTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Specify the source workspace/version/microversion in the URL and specify the target workspace/version/microversion in the query parameters.
     * Compare app element JSON trees between workspaces/versions/microversions in a document.
     */
    async compareAppElementJsonRaw(requestParameters: CompareAppElementJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDiffJsonResponse2725>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling compareAppElementJson.');
        }

        const queryParameters: any = {};

        if (requestParameters.workspaceId !== undefined) {
            queryParameters['workspaceId'] = requestParameters.workspaceId;
        }

        if (requestParameters.versionId !== undefined) {
            queryParameters['versionId'] = requestParameters.versionId;
        }

        if (requestParameters.microversionId !== undefined) {
            queryParameters['microversionId'] = requestParameters.microversionId;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.jsonDifferenceFormat !== undefined) {
            queryParameters['jsonDifferenceFormat'] = requestParameters.jsonDifferenceFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/compare`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDiffJsonResponse2725FromJSON(jsonValue));
    }

    /**
     * Specify the source workspace/version/microversion in the URL and specify the target workspace/version/microversion in the query parameters.
     * Compare app element JSON trees between workspaces/versions/microversions in a document.
     */
    async compareAppElementJson(requestParameters: CompareAppElementJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDiffJsonResponse2725> {
        const response = await this.compareAppElementJsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new application element.
     */
    async createElementRaw(requestParameters: CreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createElement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling createElement.');
        }

        if (requestParameters.bTAppElementParams === null || requestParameters.bTAppElementParams === undefined) {
            throw new runtime.RequiredError('bTAppElementParams','Required parameter requestParameters.bTAppElementParams was null or undefined when calling createElement.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementParamsToJSON(requestParameters.bTAppElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Create a new application element.
     */
    async createElement(requestParameters: CreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.createElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a reference to an app element.
     */
    async createReferenceRaw(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling createReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling createReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling createReference.');
        }

        if (requestParameters.bTAppElementReferenceParams === null || requestParameters.bTAppElementReferenceParams === undefined) {
            throw new runtime.RequiredError('bTAppElementReferenceParams','Required parameter requestParameters.bTAppElementReferenceParams was null or undefined when calling createReference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementReferenceParamsToJSON(requestParameters.bTAppElementReferenceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Creates a reference to an app element.
     */
    async createReference(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.createReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the content from the specified app element.
     */
    async deleteAppElementContentRaw(requestParameters: DeleteAppElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.sid === null || requestParameters.sid === undefined) {
            throw new runtime.RequiredError('sid','Required parameter requestParameters.sid was null or undefined when calling deleteAppElementContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements/{sid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"sid"}}`, encodeURIComponent(String(requestParameters.sid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Deletes the content from the specified app element.
     */
    async deleteAppElementContent(requestParameters: DeleteAppElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.deleteAppElementContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete multiple subelements array by document ID, workspace or version or microversion ID, tab ID, and subelement IDs.
     */
    async deleteAppElementContentBatchRaw(requestParameters: DeleteAppElementContentBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteAppElementContentBatch.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteAppElementContentBatch.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling deleteAppElementContentBatch.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling deleteAppElementContentBatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.subelementIds) {
            queryParameters['subelementIds'] = requestParameters.subelementIds;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Delete multiple subelements array by document ID, workspace or version or microversion ID, tab ID, and subelement IDs.
     */
    async deleteAppElementContentBatch(requestParameters: DeleteAppElementContentBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.deleteAppElementContentBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a blob subelement from an app element.
     */
    async deleteBlobSubelementRaw(requestParameters: DeleteBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling deleteBlobSubelement.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Delete a blob subelement from an app element.
     */
    async deleteBlobSubelement(requestParameters: DeleteBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.deleteBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an app element reference.
     */
    async deleteReferenceRaw(requestParameters: DeleteReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling deleteReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling deleteReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling deleteReference.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Delete an app element reference.
     */
    async deleteReference(requestParameters: DeleteReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.deleteReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a blob subelement as a file.
     * Download a blob subelement from the specified app element.
     */
    async downloadBlobSubelementRaw(requestParameters: DownloadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.vm === null || requestParameters.vm === undefined) {
            throw new runtime.RequiredError('vm','Required parameter requestParameters.vm was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.vmid === null || requestParameters.vmid === undefined) {
            throw new runtime.RequiredError('vmid','Required parameter requestParameters.vmid was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling downloadBlobSubelement.');
        }

        const queryParameters: any = {};

        if (requestParameters.contentDisposition !== undefined) {
            queryParameters['contentDisposition'] = requestParameters.contentDisposition;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{vm}/{vmid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"vm"}}`, encodeURIComponent(String(requestParameters.vm))).replace(`{${"vmid"}}`, encodeURIComponent(String(requestParameters.vmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Download a blob subelement as a file.
     * Download a blob subelement from the specified app element.
     */
    async downloadBlobSubelement(requestParameters: DownloadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The downloaded file can be used to retrieve stored subelements.
     * Download the blob element (i.e., a file) stored in an app element in a document\'s workspace.
     */
    async downloadBlobSubelementWorkspaceRaw(requestParameters: DownloadBlobSubelementWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        const queryParameters: any = {};

        if (requestParameters.contentDisposition !== undefined) {
            queryParameters['contentDisposition'] = requestParameters.contentDisposition;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * The downloaded file can be used to retrieve stored subelements.
     * Download the blob element (i.e., a file) stored in an app element in a document\'s workspace.
     */
    async downloadBlobSubelementWorkspace(requestParameters: DownloadBlobSubelementWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadBlobSubelementWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the history of the specified all element.
     */
    async getAppElementHistoryRaw(requestParameters: GetAppElementHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementHistoryInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getAppElementHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/history`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementHistoryInfoFromJSON(jsonValue));
    }

    /**
     * Get the history of the specified all element.
     */
    async getAppElementHistory(requestParameters: GetAppElementHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementHistoryInfo> {
        const response = await this.getAppElementHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all blob subelement IDs for the specified workspace, version, or microversion.
     */
    async getBlobSubelementIdsRaw(requestParameters: GetBlobSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementIdsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getBlobSubelementIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/blob`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementIdsInfoFromJSON(jsonValue));
    }

    /**
     * Get a list of all blob subelement IDs for the specified workspace, version, or microversion.
     */
    async getBlobSubelementIds(requestParameters: GetBlobSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementIdsInfo> {
        const response = await this.getBlobSubelementIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all transactions performed on an element.
     */
    async getElementTransactionsRaw(requestParameters: GetElementTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementTransactionsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getElementTransactions.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getElementTransactions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling getElementTransactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementTransactionsInfoFromJSON(jsonValue));
    }

    /**
     * Get a list of all transactions performed on an element.
     */
    async getElementTransactions(requestParameters: GetElementTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementTransactionsInfo> {
        const response = await this.getElementTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the full JSON tree for the specified workspace/version/microversion.
     */
    async getJsonRaw(requestParameters: GetJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGetJsonResponse2137>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getJson.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getJson.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getJson.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getJson.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/json`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGetJsonResponse2137FromJSON(jsonValue));
    }

    /**
     * Get the full JSON tree for the specified workspace/version/microversion.
     */
    async getJson(requestParameters: GetJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGetJsonResponse2137> {
        const response = await this.getJsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this endpoint to return the JSON at the specified path instead of returning the entire JSON for the element. This POST endpoint does not write any information.
     * Get the JSON at specified paths for an element.
     */
    async getJsonPathsRaw(requestParameters: GetJsonPathsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGetJsonPathsResponse1544>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getJsonPaths.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/jsonpaths`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTGetJsonPaths1697ToJSON(requestParameters.bTGetJsonPaths1697),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGetJsonPathsResponse1544FromJSON(jsonValue));
    }

    /**
     * Use this endpoint to return the JSON at the specified path instead of returning the entire JSON for the element. This POST endpoint does not write any information.
     * Get the JSON at specified paths for an element.
     */
    async getJsonPaths(requestParameters: GetJsonPathsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGetJsonPathsResponse1544> {
        const response = await this.getJsonPathsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all subelement IDs in a specified workspace/version/microversion.
     */
    async getSubElementContentRaw(requestParameters: GetSubElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementContentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getSubElementContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        if (requestParameters.baseChangeId !== undefined) {
            queryParameters['baseChangeId'] = requestParameters.baseChangeId;
        }

        if (requestParameters.subelementId !== undefined) {
            queryParameters['subelementId'] = requestParameters.subelementId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementContentInfoFromJSON(jsonValue));
    }

    /**
     * Get a list of all subelement IDs in a specified workspace/version/microversion.
     */
    async getSubElementContent(requestParameters: GetSubElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementContentInfo> {
        const response = await this.getSubElementContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all subelement IDs in a specified workspace/version/microversion.
     */
    async getSubelementIdsRaw(requestParameters: GetSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementIdsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getSubelementIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/ids`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementIdsInfoFromJSON(jsonValue));
    }

    /**
     * Get a list of all subelement IDs in a specified workspace/version/microversion.
     */
    async getSubelementIds(requestParameters: GetSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementIdsInfo> {
        const response = await this.getSubelementIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve all references for all workspace elements. For bulk operations  only. Use `resolveReferences` for a single element.
     * Resolves bulk app element references.
     */
    async resolveAllElementReferencesRaw(requestParameters: ResolveAllElementReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: BTAppElementReferencesResolveInfo; }>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling resolveAllElementReferences.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling resolveAllElementReferences.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling resolveAllElementReferences.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.includeInternal !== undefined) {
            queryParameters['includeInternal'] = requestParameters.includeInternal;
        }

        if (requestParameters.referenceIds !== undefined) {
            queryParameters['referenceIds'] = requestParameters.referenceIds;
        }

        if (requestParameters.elementIds !== undefined) {
            queryParameters['elementIds'] = requestParameters.elementIds;
        }

        if (requestParameters.drawingsOnly !== undefined) {
            queryParameters['drawingsOnly'] = requestParameters.drawingsOnly;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/resolvereferences`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => runtime.mapValues(jsonValue, BTAppElementReferencesResolveInfoFromJSON));
    }

    /**
     * Resolve all references for all workspace elements. For bulk operations  only. Use `resolveReferences` for a single element.
     * Resolves bulk app element references.
     */
    async resolveAllElementReferences(requestParameters: ResolveAllElementReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: BTAppElementReferencesResolveInfo; }> {
        const response = await this.resolveAllElementReferencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For single operations only. Use `resolveReferences` for bulk operations.
     * Resolves a single reference to an app element.
     */
    async resolveReferenceRaw(requestParameters: ResolveReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceResolveInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling resolveReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling resolveReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling resolveReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling resolveReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling resolveReference.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.includeInternal !== undefined) {
            queryParameters['includeInternal'] = requestParameters.includeInternal;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceResolveInfoFromJSON(jsonValue));
    }

    /**
     * For single operations only. Use `resolveReferences` for bulk operations.
     * Resolves a single reference to an app element.
     */
    async resolveReference(requestParameters: ResolveReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceResolveInfo> {
        const response = await this.resolveReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For bulk operations only. Use `resolveReference` for a single operation.
     * Resolves bulk app element references.
     */
    async resolveReferencesRaw(requestParameters: ResolveReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferencesResolveInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling resolveReferences.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.includeInternal !== undefined) {
            queryParameters['includeInternal'] = requestParameters.includeInternal;
        }

        if (requestParameters.referenceIds !== undefined) {
            queryParameters['referenceIds'] = requestParameters.referenceIds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/resolvereferences`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferencesResolveInfoFromJSON(jsonValue));
    }

    /**
     * For bulk operations only. Use `resolveReference` for a single operation.
     * Resolves bulk app element references.
     */
    async resolveReferences(requestParameters: ResolveReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferencesResolveInfo> {
        const response = await this.resolveReferencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a microbranch (i.e., a branch for a new microversion).
     * Start a transaction
     */
    async startTransactionRaw(requestParameters: StartTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling startTransaction.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling startTransaction.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling startTransaction.');
        }

        if (requestParameters.bTAppElementStartTransactionParams === null || requestParameters.bTAppElementStartTransactionParams === undefined) {
            throw new runtime.RequiredError('bTAppElementStartTransactionParams','Required parameter requestParameters.bTAppElementStartTransactionParams was null or undefined when calling startTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementStartTransactionParamsToJSON(requestParameters.bTAppElementStartTransactionParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Creates a microbranch (i.e., a branch for a new microversion).
     * Start a transaction
     */
    async startTransaction(requestParameters: StartTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.startTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the content for the specified app element.
     */
    async updateAppElementRaw(requestParameters: UpdateAppElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling updateAppElement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementUpdateParamsToJSON(requestParameters.bTAppElementUpdateParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Update the content for the specified app element.
     */
    async updateAppElement(requestParameters: UpdateAppElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.updateAppElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an app element reference.
     */
    async updateReferenceRaw(requestParameters: UpdateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling updateReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling updateReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling updateReference.');
        }

        if (requestParameters.bTAppElementReferenceParams === null || requestParameters.bTAppElementReferenceParams === undefined) {
            throw new runtime.RequiredError('bTAppElementReferenceParams','Required parameter requestParameters.bTAppElementReferenceParams was null or undefined when calling updateReference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementReferenceParamsToJSON(requestParameters.bTAppElementReferenceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Update an app element reference.
     */
    async updateReference(requestParameters: UpdateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.updateReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Request body parameters are multipart fields, so you must use `\"Content-Type\":\"multipart/form-data\"` in the request header.
     * Create a new blob subelement from an uploaded file.
     */
    async uploadBlobSubelementRaw(requestParameters: UploadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling uploadBlobSubelement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.transactionId !== undefined) {
            formParams.append('transactionId', requestParameters.transactionId as any);
        }

        if (requestParameters.parentChangeId !== undefined) {
            formParams.append('parentChangeId', requestParameters.parentChangeId as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.fileContentLength !== undefined) {
            formParams.append('fileContentLength', requestParameters.fileContentLength as any);
        }

        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Request body parameters are multipart fields, so you must use `\"Content-Type\":\"multipart/form-data\"` in the request header.
     * Create a new blob subelement from an uploaded file.
     */
    async uploadBlobSubelement(requestParameters: UploadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.uploadBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetJsonWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetJsonWvmEnum = typeof GetJsonWvmEnum[keyof typeof GetJsonWvmEnum];
/**
 * @export
 */
export const GetJsonPathsWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetJsonPathsWvmEnum = typeof GetJsonPathsWvmEnum[keyof typeof GetJsonPathsWvmEnum];
/**
 * @export
 */
export const GetSubElementContentWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetSubElementContentWvmEnum = typeof GetSubElementContentWvmEnum[keyof typeof GetSubElementContentWvmEnum];
/**
 * @export
 */
export const ResolveAllElementReferencesWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type ResolveAllElementReferencesWvmEnum = typeof ResolveAllElementReferencesWvmEnum[keyof typeof ResolveAllElementReferencesWvmEnum];
/**
 * @export
 */
export const ResolveReferencesWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type ResolveReferencesWvmEnum = typeof ResolveReferencesWvmEnum[keyof typeof ResolveReferencesWvmEnum];
