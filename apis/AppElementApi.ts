/* tslint:disable */
/* eslint-disable */
/**
 * Onshape REST API
 * The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn\'t used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here\'s [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.
 *
 * The version of the OpenAPI document: 1.168.21206-13add30fbba2
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTAppElementBulkCreateInfo,
  BTAppElementBulkCreateParams,
  BTAppElementCommitTransactionParams,
  BTAppElementContentInfo,
  BTAppElementHistoryInfo,
  BTAppElementIdsInfo,
  BTAppElementModifyInfo,
  BTAppElementParams,
  BTAppElementReferenceInfo,
  BTAppElementReferenceParams,
  BTAppElementReferenceResolveInfo,
  BTAppElementReferencesResolveInfo,
  BTAppElementStartTransactionParams,
  BTAppElementTransactionsInfo,
  BTAppElementUpdateParams,
  BTDiffJsonResponse2725,
  BTGetJsonPaths1697,
  BTGetJsonPathsResponse1544,
  BTGetJsonResponse2137,
} from '../models';
import {
    BTAppElementBulkCreateInfoFromJSON,
    BTAppElementBulkCreateInfoToJSON,
    BTAppElementBulkCreateParamsFromJSON,
    BTAppElementBulkCreateParamsToJSON,
    BTAppElementCommitTransactionParamsFromJSON,
    BTAppElementCommitTransactionParamsToJSON,
    BTAppElementContentInfoFromJSON,
    BTAppElementContentInfoToJSON,
    BTAppElementHistoryInfoFromJSON,
    BTAppElementHistoryInfoToJSON,
    BTAppElementIdsInfoFromJSON,
    BTAppElementIdsInfoToJSON,
    BTAppElementModifyInfoFromJSON,
    BTAppElementModifyInfoToJSON,
    BTAppElementParamsFromJSON,
    BTAppElementParamsToJSON,
    BTAppElementReferenceInfoFromJSON,
    BTAppElementReferenceInfoToJSON,
    BTAppElementReferenceParamsFromJSON,
    BTAppElementReferenceParamsToJSON,
    BTAppElementReferenceResolveInfoFromJSON,
    BTAppElementReferenceResolveInfoToJSON,
    BTAppElementReferencesResolveInfoFromJSON,
    BTAppElementReferencesResolveInfoToJSON,
    BTAppElementStartTransactionParamsFromJSON,
    BTAppElementStartTransactionParamsToJSON,
    BTAppElementTransactionsInfoFromJSON,
    BTAppElementTransactionsInfoToJSON,
    BTAppElementUpdateParamsFromJSON,
    BTAppElementUpdateParamsToJSON,
    BTDiffJsonResponse2725FromJSON,
    BTDiffJsonResponse2725ToJSON,
    BTGetJsonPaths1697FromJSON,
    BTGetJsonPaths1697ToJSON,
    BTGetJsonPathsResponse1544FromJSON,
    BTGetJsonPathsResponse1544ToJSON,
    BTGetJsonResponse2137FromJSON,
    BTGetJsonResponse2137ToJSON,
} from '../models';

export interface AbortTransactionRequest {
    did: string;
    eid: string;
    wid: string;
    tid: string;
    returnError?: boolean;
}

export interface BulkCreateElementRequest {
    did: string;
    wid: string;
    bTAppElementBulkCreateParams: BTAppElementBulkCreateParams;
    linkDocumentId?: string;
}

export interface CommitTransactionsRequest {
    did: string;
    wid: string;
    bTAppElementCommitTransactionParams: BTAppElementCommitTransactionParams;
    linkDocumentId?: string;
}

export interface CompareAppElementJsonRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    workspaceId?: string;
    versionId?: string;
    microversionId?: string;
    linkDocumentId?: string;
    jsonDifferenceFormat?: string;
}

export interface CreateElementRequest {
    did: string;
    wid: string;
    bTAppElementParams: BTAppElementParams;
    linkDocumentId?: string;
}

export interface CreateReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    bTAppElementReferenceParams: BTAppElementReferenceParams;
}

export interface DeleteAppElementContentRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    sid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
}

export interface DeleteBlobSubelementRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    transactionId?: string;
    changeId?: string;
}

export interface DeleteReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
}

export interface DownloadBlobSubelementRequest {
    did: string;
    vm: string;
    vmid: string;
    eid: string;
    bid: string;
    contentDisposition?: string;
    ifNoneMatch?: string;
    transactionId?: string;
    changeId?: string;
    linkDocumentId?: string;
}

export interface DownloadBlobSubelementWorkspaceRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    contentDisposition?: string;
    ifNoneMatch?: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetAppElementHistoryRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
}

export interface GetBlobSubelementIdsRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetElementTransactionsRequest {
    did: string;
    eid: string;
    wid: string;
}

export interface GetJsonRequest {
    did: string;
    wvm: GetJsonWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
}

export interface GetJsonPathsRequest {
    did: string;
    wvm: GetJsonPathsWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
    bTGetJsonPaths1697?: BTGetJsonPaths1697;
}

export interface GetSubElementContentRequest {
    did: string;
    wvm: GetSubElementContentWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    changeId?: string;
    baseChangeId?: string;
    subelementId?: string;
}

export interface GetSubelementIdsRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    transactionId?: string;
    changeId?: string;
}

export interface ResolveReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    transactionId?: string;
    parentChangeId?: string;
    includeInternal?: boolean;
    linkDocumentId?: string;
}

export interface ResolveReferencesRequest {
    did: string;
    wvm: ResolveReferencesWvmEnum;
    wvmid: string;
    eid: string;
    linkDocumentId?: string;
    transactionId?: string;
    parentChangeId?: string;
    includeInternal?: boolean;
    referenceIds?: string;
}

export interface StartTransactionRequest {
    did: string;
    eid: string;
    wid: string;
    bTAppElementStartTransactionParams: BTAppElementStartTransactionParams;
}

export interface UpdateAppElementRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    bTAppElementUpdateParams?: BTAppElementUpdateParams;
}

export interface UpdateReferenceRequest {
    did: string;
    eid: string;
    wvm: string;
    wvmid: string;
    rid: string;
    bTAppElementReferenceParams: BTAppElementReferenceParams;
}

export interface UploadBlobSubelementRequest {
    did: string;
    wid: string;
    eid: string;
    bid: string;
    transactionId?: string;
    parentChangeId?: string;
    description?: string;
    file?: Blob;
    fileContentLength?: number;
}

/**
 * 
 */
export class AppElementApi extends runtime.BaseAPI {

    /**
     * Abort transaction by document ID, workspace ID, tab ID, and transaction ID.
     */
    async abortTransactionRaw(requestParameters: AbortTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling abortTransaction.');
        }

        if (requestParameters.tid === null || requestParameters.tid === undefined) {
            throw new runtime.RequiredError('tid','Required parameter requestParameters.tid was null or undefined when calling abortTransaction.');
        }

        const queryParameters: any = {};

        if (requestParameters.returnError !== undefined) {
            queryParameters['returnError'] = requestParameters.returnError;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions/{tid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"tid"}}`, encodeURIComponent(String(requestParameters.tid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Abort transaction by document ID, workspace ID, tab ID, and transaction ID.
     */
    async abortTransaction(requestParameters: AbortTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.abortTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates several new empty application elements in the document.
     * Create multiple empty application tabs by document ID and workspace ID.
     */
    async bulkCreateElementRaw(requestParameters: BulkCreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementBulkCreateInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling bulkCreateElement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling bulkCreateElement.');
        }

        if (requestParameters.bTAppElementBulkCreateParams === null || requestParameters.bTAppElementBulkCreateParams === undefined) {
            throw new runtime.RequiredError('bTAppElementBulkCreateParams','Required parameter requestParameters.bTAppElementBulkCreateParams was null or undefined when calling bulkCreateElement.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/bulkcreate`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementBulkCreateParamsToJSON(requestParameters.bTAppElementBulkCreateParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementBulkCreateInfoFromJSON(jsonValue));
    }

    /**
     * Creates several new empty application elements in the document.
     * Create multiple empty application tabs by document ID and workspace ID.
     */
    async bulkCreateElement(requestParameters: BulkCreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementBulkCreateInfo> {
        const response = await this.bulkCreateElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Commit transactions by document ID and workspace ID.
     */
    async commitTransactionsRaw(requestParameters: CommitTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling commitTransactions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling commitTransactions.');
        }

        if (requestParameters.bTAppElementCommitTransactionParams === null || requestParameters.bTAppElementCommitTransactionParams === undefined) {
            throw new runtime.RequiredError('bTAppElementCommitTransactionParams','Required parameter requestParameters.bTAppElementCommitTransactionParams was null or undefined when calling commitTransactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementCommitTransactionParamsToJSON(requestParameters.bTAppElementCommitTransactionParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Commit transactions by document ID and workspace ID.
     */
    async commitTransactions(requestParameters: CommitTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.commitTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Compare JSON by document ID, workspace or version or microversion ID, and tab ID.
     */
    async compareAppElementJsonRaw(requestParameters: CompareAppElementJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDiffJsonResponse2725>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling compareAppElementJson.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling compareAppElementJson.');
        }

        const queryParameters: any = {};

        if (requestParameters.workspaceId !== undefined) {
            queryParameters['workspaceId'] = requestParameters.workspaceId;
        }

        if (requestParameters.versionId !== undefined) {
            queryParameters['versionId'] = requestParameters.versionId;
        }

        if (requestParameters.microversionId !== undefined) {
            queryParameters['microversionId'] = requestParameters.microversionId;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.jsonDifferenceFormat !== undefined) {
            queryParameters['jsonDifferenceFormat'] = requestParameters.jsonDifferenceFormat;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/compare`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDiffJsonResponse2725FromJSON(jsonValue));
    }

    /**
     * Compare JSON by document ID, workspace or version or microversion ID, and tab ID.
     */
    async compareAppElementJson(requestParameters: CompareAppElementJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDiffJsonResponse2725> {
        const response = await this.compareAppElementJsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create application tab by document ID and workspace ID.
     */
    async createElementRaw(requestParameters: CreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createElement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling createElement.');
        }

        if (requestParameters.bTAppElementParams === null || requestParameters.bTAppElementParams === undefined) {
            throw new runtime.RequiredError('bTAppElementParams','Required parameter requestParameters.bTAppElementParams was null or undefined when calling createElement.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementParamsToJSON(requestParameters.bTAppElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Create application tab by document ID and workspace ID.
     */
    async createElement(requestParameters: CreateElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.createElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create referencesby document ID, workspace or version or microversion ID, and tab ID.
     */
    async createReferenceRaw(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling createReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling createReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling createReference.');
        }

        if (requestParameters.bTAppElementReferenceParams === null || requestParameters.bTAppElementReferenceParams === undefined) {
            throw new runtime.RequiredError('bTAppElementReferenceParams','Required parameter requestParameters.bTAppElementReferenceParams was null or undefined when calling createReference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write", "OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementReferenceParamsToJSON(requestParameters.bTAppElementReferenceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Create referencesby document ID, workspace or version or microversion ID, and tab ID.
     */
    async createReference(requestParameters: CreateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.createReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete subelement array by document ID, workspace or version or microversion ID, tab ID, and subelement ID. A Subelement is used to store and organize data.
     */
    async deleteAppElementContentRaw(requestParameters: DeleteAppElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling deleteAppElementContent.');
        }

        if (requestParameters.sid === null || requestParameters.sid === undefined) {
            throw new runtime.RequiredError('sid','Required parameter requestParameters.sid was null or undefined when calling deleteAppElementContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements/{sid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"sid"}}`, encodeURIComponent(String(requestParameters.sid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Delete subelement array by document ID, workspace or version or microversion ID, tab ID, and subelement ID. A Subelement is used to store and organize data.
     */
    async deleteAppElementContent(requestParameters: DeleteAppElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.deleteAppElementContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async deleteBlobSubelementRaw(requestParameters: DeleteBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling deleteBlobSubelement.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Delete blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async deleteBlobSubelement(requestParameters: DeleteBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.deleteBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.
     */
    async deleteReferenceRaw(requestParameters: DeleteReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling deleteReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling deleteReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling deleteReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling deleteReference.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Delete references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.
     */
    async deleteReference(requestParameters: DeleteReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.deleteReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download blob subelement file by document ID, version or microversion ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async downloadBlobSubelementRaw(requestParameters: DownloadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.vm === null || requestParameters.vm === undefined) {
            throw new runtime.RequiredError('vm','Required parameter requestParameters.vm was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.vmid === null || requestParameters.vmid === undefined) {
            throw new runtime.RequiredError('vmid','Required parameter requestParameters.vmid was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling downloadBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling downloadBlobSubelement.');
        }

        const queryParameters: any = {};

        if (requestParameters.contentDisposition !== undefined) {
            queryParameters['contentDisposition'] = requestParameters.contentDisposition;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{vm}/{vmid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"vm"}}`, encodeURIComponent(String(requestParameters.vm))).replace(`{${"vmid"}}`, encodeURIComponent(String(requestParameters.vmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Download blob subelement file by document ID, version or microversion ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async downloadBlobSubelement(requestParameters: DownloadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download blob subelement as a file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async downloadBlobSubelementWorkspaceRaw(requestParameters: DownloadBlobSubelementWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling downloadBlobSubelementWorkspace.');
        }

        const queryParameters: any = {};

        if (requestParameters.contentDisposition !== undefined) {
            queryParameters['contentDisposition'] = requestParameters.contentDisposition;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Download blob subelement as a file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async downloadBlobSubelementWorkspace(requestParameters: DownloadBlobSubelementWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadBlobSubelementWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve history by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getAppElementHistoryRaw(requestParameters: GetAppElementHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementHistoryInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getAppElementHistory.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getAppElementHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/history`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementHistoryInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve history by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getAppElementHistory(requestParameters: GetAppElementHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementHistoryInfo> {
        const response = await this.getAppElementHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an array of blob subelement IDs by document ID and workspace or microversion ID. A Subelement is used to store and organize data.
     */
    async getBlobSubelementIdsRaw(requestParameters: GetBlobSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementIdsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getBlobSubelementIds.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getBlobSubelementIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/blob`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementIdsInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve an array of blob subelement IDs by document ID and workspace or microversion ID. A Subelement is used to store and organize data.
     */
    async getBlobSubelementIds(requestParameters: GetBlobSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementIdsInfo> {
        const response = await this.getBlobSubelementIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an array of tab transactions by document ID, workspace ID, and tab ID.
     */
    async getElementTransactionsRaw(requestParameters: GetElementTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementTransactionsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getElementTransactions.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getElementTransactions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling getElementTransactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementTransactionsInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve an array of tab transactions by document ID, workspace ID, and tab ID.
     */
    async getElementTransactions(requestParameters: GetElementTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementTransactionsInfo> {
        const response = await this.getElementTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve JSON by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getJsonRaw(requestParameters: GetJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGetJsonResponse2137>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getJson.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getJson.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getJson.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getJson.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/json`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGetJsonResponse2137FromJSON(jsonValue));
    }

    /**
     * Retrieve JSON by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getJson(requestParameters: GetJsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGetJsonResponse2137> {
        const response = await this.getJsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve JSON paths by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getJsonPathsRaw(requestParameters: GetJsonPathsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGetJsonPathsResponse1544>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getJsonPaths.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getJsonPaths.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/jsonpaths`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTGetJsonPaths1697ToJSON(requestParameters.bTGetJsonPaths1697),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGetJsonPathsResponse1544FromJSON(jsonValue));
    }

    /**
     * Retrieve JSON paths by document ID, workspace or version or microversion ID, and tab ID.
     */
    async getJsonPaths(requestParameters: GetJsonPathsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGetJsonPathsResponse1544> {
        const response = await this.getJsonPathsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve subelement content by document ID, tab ID, and workspace or version or microversion ID. A Subelement is used to store and organize data.
     */
    async getSubElementContentRaw(requestParameters: GetSubElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementContentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getSubElementContent.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getSubElementContent.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        if (requestParameters.baseChangeId !== undefined) {
            queryParameters['baseChangeId'] = requestParameters.baseChangeId;
        }

        if (requestParameters.subelementId !== undefined) {
            queryParameters['subelementId'] = requestParameters.subelementId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementContentInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve subelement content by document ID, tab ID, and workspace or version or microversion ID. A Subelement is used to store and organize data.
     */
    async getSubElementContent(requestParameters: GetSubElementContentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementContentInfo> {
        const response = await this.getSubElementContentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve subelement IDs by document ID, workspace or version or microversion ID, and tab ID. A Subelement is used to store and organize data.
     */
    async getSubelementIdsRaw(requestParameters: GetSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementIdsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getSubelementIds.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getSubelementIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.changeId !== undefined) {
            queryParameters['changeId'] = requestParameters.changeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/ids`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementIdsInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve subelement IDs by document ID, workspace or version or microversion ID, and tab ID. A Subelement is used to store and organize data.
     */
    async getSubelementIds(requestParameters: GetSubelementIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementIdsInfo> {
        const response = await this.getSubelementIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve references by document ID, workspace or version or microversion ID, tab ID and resolve ID.
     */
    async resolveReferenceRaw(requestParameters: ResolveReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceResolveInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling resolveReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling resolveReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling resolveReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling resolveReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling resolveReference.');
        }

        const queryParameters: any = {};

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.includeInternal !== undefined) {
            queryParameters['includeInternal'] = requestParameters.includeInternal;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceResolveInfoFromJSON(jsonValue));
    }

    /**
     * Resolve references by document ID, workspace or version or microversion ID, tab ID and resolve ID.
     */
    async resolveReference(requestParameters: ResolveReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceResolveInfo> {
        const response = await this.resolveReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve references by document ID, workspace or version or microversion ID, and tab ID.
     */
    async resolveReferencesRaw(requestParameters: ResolveReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferencesResolveInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling resolveReferences.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling resolveReferences.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.transactionId !== undefined) {
            queryParameters['transactionId'] = requestParameters.transactionId;
        }

        if (requestParameters.parentChangeId !== undefined) {
            queryParameters['parentChangeId'] = requestParameters.parentChangeId;
        }

        if (requestParameters.includeInternal !== undefined) {
            queryParameters['includeInternal'] = requestParameters.includeInternal;
        }

        if (requestParameters.referenceIds !== undefined) {
            queryParameters['referenceIds'] = requestParameters.referenceIds;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/resolvereferences`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferencesResolveInfoFromJSON(jsonValue));
    }

    /**
     * Resolve references by document ID, workspace or version or microversion ID, and tab ID.
     */
    async resolveReferences(requestParameters: ResolveReferencesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferencesResolveInfo> {
        const response = await this.resolveReferencesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start application tab transaction by document ID, workspace ID, and tab ID.
     */
    async startTransactionRaw(requestParameters: StartTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling startTransaction.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling startTransaction.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling startTransaction.');
        }

        if (requestParameters.bTAppElementStartTransactionParams === null || requestParameters.bTAppElementStartTransactionParams === undefined) {
            throw new runtime.RequiredError('bTAppElementStartTransactionParams','Required parameter requestParameters.bTAppElementStartTransactionParams was null or undefined when calling startTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/transactions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementStartTransactionParamsToJSON(requestParameters.bTAppElementStartTransactionParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Start application tab transaction by document ID, workspace ID, and tab ID.
     */
    async startTransaction(requestParameters: StartTransactionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.startTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update application tab by document ID, workspace or version or microversion ID, and tab ID.
     */
    async updateAppElementRaw(requestParameters: UpdateAppElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling updateAppElement.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling updateAppElement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementUpdateParamsToJSON(requestParameters.bTAppElementUpdateParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Update application tab by document ID, workspace or version or microversion ID, and tab ID.
     */
    async updateAppElement(requestParameters: UpdateAppElementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.updateAppElementRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.
     */
    async updateReferenceRaw(requestParameters: UpdateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementReferenceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateReference.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateReference.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling updateReference.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling updateReference.');
        }

        if (requestParameters.rid === null || requestParameters.rid === undefined) {
            throw new runtime.RequiredError('rid','Required parameter requestParameters.rid was null or undefined when calling updateReference.');
        }

        if (requestParameters.bTAppElementReferenceParams === null || requestParameters.bTAppElementReferenceParams === undefined) {
            throw new runtime.RequiredError('bTAppElementReferenceParams','Required parameter requestParameters.bTAppElementReferenceParams was null or undefined when calling updateReference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write", "OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"rid"}}`, encodeURIComponent(String(requestParameters.rid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAppElementReferenceParamsToJSON(requestParameters.bTAppElementReferenceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementReferenceInfoFromJSON(jsonValue));
    }

    /**
     * Update references by document ID, workspace or version or microversion ID, tab ID, and resolve ID.
     */
    async updateReference(requestParameters: UpdateReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementReferenceInfo> {
        const response = await this.updateReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async uploadBlobSubelementRaw(requestParameters: UploadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAppElementModifyInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling uploadBlobSubelement.');
        }

        if (requestParameters.bid === null || requestParameters.bid === undefined) {
            throw new runtime.RequiredError('bid','Required parameter requestParameters.bid was null or undefined when calling uploadBlobSubelement.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.transactionId !== undefined) {
            formParams.append('transactionId', requestParameters.transactionId as any);
        }

        if (requestParameters.parentChangeId !== undefined) {
            formParams.append('parentChangeId', requestParameters.parentChangeId as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.fileContentLength !== undefined) {
            formParams.append('fileContentLength', requestParameters.fileContentLength as any);
        }

        const response = await this.request({
            path: `/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"bid"}}`, encodeURIComponent(String(requestParameters.bid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAppElementModifyInfoFromJSON(jsonValue));
    }

    /**
     * Upload blob subelement file by document ID, workspace ID, tab ID, and blob ID. A Subelement is used to store and organize data.
     */
    async uploadBlobSubelement(requestParameters: UploadBlobSubelementRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAppElementModifyInfo> {
        const response = await this.uploadBlobSubelementRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetJsonWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetJsonWvmEnum = typeof GetJsonWvmEnum[keyof typeof GetJsonWvmEnum];
/**
 * @export
 */
export const GetJsonPathsWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetJsonPathsWvmEnum = typeof GetJsonPathsWvmEnum[keyof typeof GetJsonPathsWvmEnum];
/**
 * @export
 */
export const GetSubElementContentWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetSubElementContentWvmEnum = typeof GetSubElementContentWvmEnum[keyof typeof GetSubElementContentWvmEnum];
/**
 * @export
 */
export const ResolveReferencesWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type ResolveReferencesWvmEnum = typeof ResolveReferencesWvmEnum[keyof typeof ResolveReferencesWvmEnum];
