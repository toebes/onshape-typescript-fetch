/* tslint:disable */
/* eslint-disable */
/**
 * Onshape REST API
 * The Onshape REST API consumed by all client. # Authorization The simplest way to authorize and enable the **Try it out** functionality is to sign in to Onshape and use the current session. The **Authorize** button enables other authorization techniques. To ensure the current session isn\'t used when trying other authentication techniques, make sure to remove the Onshape cookie as per the instructions for your particular browser. Alternatively, a private or incognito window may be used. Here\'s [how to remove a specific cookie on Chrome](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site). - **Current Session** authorization is enabled by default if the browser is already signed in to [Onshape](/). - **OAuth2** authorization uses an Onshape OAuth2 app created on the [Onshape Developer Portal](https://dev-portal.onshape.com/oauthApps). The redirect URL field should include `https://cad.onshape.com/glassworks/explorer/oauth2-redirect.html`. - **API Key** authorization using basic authentication is also available. The keys can be generated in the [Onshape Developer Portal](https://dev-portal.onshape.com/keys). In the authentication dialog, enter the access key in the `Username` field, and enter the secret key in the `Password` field. Basic authentication should only be used during the development process since sharing API Keys provides the same level of access as a username and password.
 *
 * The version of the OpenAPI document: 1.164.16301-d273853a12e7
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTAclInfo,
  BTBExportModelParams,
  BTCopyDocumentInfo,
  BTCopyDocumentParams,
  BTDocumentElementInfo,
  BTDocumentHistoryInfo,
  BTDocumentInfo,
  BTDocumentMergeInfo,
  BTDocumentParams,
  BTDocumentSearchParams,
  BTGlobalTreeNodeListResponse,
  BTInsertablesListResponse,
  BTLinkToLatestDocumentInfo,
  BTLinkToLatestDocumentParams,
  BTMergePreviewInfo,
  BTMicroversionInfo,
  BTMoveElementInfo,
  BTMoveElementParams,
  BTRestoreFromHistoryInfo,
  BTRevertUnchangedParams,
  BTShareParams,
  BTSyncAppElementParams,
  BTUnchangedElementInfo,
  BTUnitInfo,
  BTVersionInfo,
  BTVersionOrWorkspaceMergeInfo,
  BTVersionOrWorkspaceParams,
  BTWorkspaceInfo,
} from '../models';
import {
    BTAclInfoFromJSON,
    BTAclInfoToJSON,
    BTBExportModelParamsFromJSON,
    BTBExportModelParamsToJSON,
    BTCopyDocumentInfoFromJSON,
    BTCopyDocumentInfoToJSON,
    BTCopyDocumentParamsFromJSON,
    BTCopyDocumentParamsToJSON,
    BTDocumentElementInfoFromJSON,
    BTDocumentElementInfoToJSON,
    BTDocumentHistoryInfoFromJSON,
    BTDocumentHistoryInfoToJSON,
    BTDocumentInfoFromJSON,
    BTDocumentInfoToJSON,
    BTDocumentMergeInfoFromJSON,
    BTDocumentMergeInfoToJSON,
    BTDocumentParamsFromJSON,
    BTDocumentParamsToJSON,
    BTDocumentSearchParamsFromJSON,
    BTDocumentSearchParamsToJSON,
    BTGlobalTreeNodeListResponseFromJSON,
    BTGlobalTreeNodeListResponseToJSON,
    BTInsertablesListResponseFromJSON,
    BTInsertablesListResponseToJSON,
    BTLinkToLatestDocumentInfoFromJSON,
    BTLinkToLatestDocumentInfoToJSON,
    BTLinkToLatestDocumentParamsFromJSON,
    BTLinkToLatestDocumentParamsToJSON,
    BTMergePreviewInfoFromJSON,
    BTMergePreviewInfoToJSON,
    BTMicroversionInfoFromJSON,
    BTMicroversionInfoToJSON,
    BTMoveElementInfoFromJSON,
    BTMoveElementInfoToJSON,
    BTMoveElementParamsFromJSON,
    BTMoveElementParamsToJSON,
    BTRestoreFromHistoryInfoFromJSON,
    BTRestoreFromHistoryInfoToJSON,
    BTRevertUnchangedParamsFromJSON,
    BTRevertUnchangedParamsToJSON,
    BTShareParamsFromJSON,
    BTShareParamsToJSON,
    BTSyncAppElementParamsFromJSON,
    BTSyncAppElementParamsToJSON,
    BTUnchangedElementInfoFromJSON,
    BTUnchangedElementInfoToJSON,
    BTUnitInfoFromJSON,
    BTUnitInfoToJSON,
    BTVersionInfoFromJSON,
    BTVersionInfoToJSON,
    BTVersionOrWorkspaceMergeInfoFromJSON,
    BTVersionOrWorkspaceMergeInfoToJSON,
    BTVersionOrWorkspaceParamsFromJSON,
    BTVersionOrWorkspaceParamsToJSON,
    BTWorkspaceInfoFromJSON,
    BTWorkspaceInfoToJSON,
} from '../models';

export interface CopyWorkspaceRequest {
    did: string;
    wid: string;
    bTCopyDocumentParams: BTCopyDocumentParams;
}

export interface CreateDocumentRequest {
    bTDocumentParams: BTDocumentParams;
}

export interface CreateVersionRequest {
    did: string;
    bTVersionOrWorkspaceParams: BTVersionOrWorkspaceParams;
}

export interface CreateWorkspaceRequest {
    did: string;
    bTVersionOrWorkspaceParams?: BTVersionOrWorkspaceParams;
}

export interface DeleteDocumentRequest {
    did: string;
    forever?: boolean;
}

export interface DeleteWorkspaceRequest {
    did: string;
    wid: string;
}

export interface DownloadExternalDataRequest {
    did: string;
    fid: string;
    ifNoneMatch?: string;
}

export interface Export2JsonRequest {
    did: string;
    wv: Export2JsonWvEnum;
    wvid: string;
    eid: string;
    linkDocumentId?: string;
    bTBExportModelParams?: BTBExportModelParams;
}

export interface GetCurrentMicroversionRequest {
    did: string;
    wv: string;
    wvid: string;
}

export interface GetDocumentRequest {
    did: string;
}

export interface GetDocumentAclRequest {
    did: string;
}

export interface GetDocumentHistoryRequest {
    did: string;
    wm: string;
    wmid: string;
}

export interface GetDocumentPermissionSetRequest {
    did: string;
}

export interface GetDocumentVersionsRequest {
    did: string;
    offset?: number;
    limit?: number;
}

export interface GetDocumentWorkspacesRequest {
    did: string;
}

export interface GetDocumentsRequest {
    q?: string;
    filter?: number;
    owner?: string;
    ownerType?: number;
    sortColumn?: string;
    sortOrder?: string;
    offset?: number;
    limit?: number;
    label?: string;
    project?: string;
    parentId?: string;
}

export interface GetElementsInDocumentRequest {
    did: string;
    wvm: GetElementsInDocumentWvmEnum;
    wvmid: string;
    linkDocumentId?: string;
    elementType?: string;
    elementId?: string;
    withThumbnails?: boolean;
}

export interface GetInsertablesRequest {
    did: string;
    wv: string;
    wvid: string;
    elementId?: string;
    _configuration?: string;
    betaCapabilityIds?: Set<string>;
    includeParts?: boolean;
    includeSurfaces?: boolean;
    includeSketches?: boolean;
    includeReferenceFeatures?: boolean;
    includeAssemblies?: boolean;
    includeFeatureStudios?: boolean;
    includeBlobs?: boolean;
    allowedBlobMimeTypes?: string;
    excludeNewerFSVersions?: boolean;
    maxFeatureScriptVersion?: number;
    includePartStudios?: boolean;
    includeFeatures?: boolean;
    includeMeshes?: boolean;
    includeWires?: boolean;
    includeFlattenedBodies?: boolean;
    includeApplications?: boolean;
    allowedApplicationMimeTypes?: string;
    includeCompositeParts?: boolean;
    includeFSTables?: boolean;
    includeFSComputedPartPropertyFunctions?: boolean;
    includeVariables?: boolean;
    includeVariableStudios?: boolean;
    allowedBlobExtensions?: string;
}

export interface GetUnitInfoRequest {
    did: string;
    wvm: GetUnitInfoWvmEnum;
    wvmid: string;
    linkDocumentId?: string;
}

export interface GetVersionRequest {
    did: string;
    vid: string;
    parents?: boolean;
    linkDocumentId?: string;
}

export interface MergeIntoWorkspaceRequest {
    did: string;
    wid: string;
    bTVersionOrWorkspaceMergeInfo: BTVersionOrWorkspaceMergeInfo;
}

export interface MergePreviewRequest {
    did: string;
    wid: string;
    sourceType: string;
    sourceId: string;
    linkDocumentId?: string;
}

export interface MoveElementsToDocumentRequest {
    did: string;
    wid: string;
    bTMoveElementParams: BTMoveElementParams;
}

export interface RestoreFromHistoryRequest {
    did: string;
    wid: string;
    vm: string;
    vmid: string;
    linkDocumentId?: string;
}

export interface RevertUnchangedToRevisionsRequest {
    did: string;
    wid: string;
    bTRevertUnchangedParams?: BTRevertUnchangedParams;
}

export interface SearchRequest {
    bTDocumentSearchParams: BTDocumentSearchParams;
}

export interface ShareDocumentRequest {
    did: string;
    bTShareParams: BTShareParams;
}

export interface ShareWithSupportRequest {
    did: string;
}

export interface SyncApplicationElementsRequest {
    did: string;
    wid: string;
    bTSyncAppElementParams: BTSyncAppElementParams;
}

export interface UnShareDocumentRequest {
    did: string;
    eid: string;
    entryType?: number;
}

export interface UnshareFromSupportRequest {
    did: string;
}

export interface UpdateDocumentAttributesRequest {
    did: string;
    bTDocumentParams: BTDocumentParams;
}

export interface UpdateExternalReferencesToLatestDocumentsRequest {
    did: string;
    wid: string;
    eid: string;
    bTLinkToLatestDocumentParams?: BTLinkToLatestDocumentParams;
}

/**
 * 
 */
export class DocumentApi extends runtime.BaseAPI {

    /**
     * Copy workspace by document ID and workspace ID.
     */
    async copyWorkspaceRaw(requestParameters: CopyWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTCopyDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling copyWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling copyWorkspace.');
        }

        if (requestParameters.bTCopyDocumentParams === null || requestParameters.bTCopyDocumentParams === undefined) {
            throw new runtime.RequiredError('bTCopyDocumentParams','Required parameter requestParameters.bTCopyDocumentParams was null or undefined when calling copyWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/workspaces/{wid}/copy`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTCopyDocumentParamsToJSON(requestParameters.bTCopyDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTCopyDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Copy workspace by document ID and workspace ID.
     */
    async copyWorkspace(requestParameters: CopyWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTCopyDocumentInfo> {
        const response = await this.copyWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create and upload a document.
     */
    async createDocumentRaw(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentInfo>> {
        if (requestParameters.bTDocumentParams === null || requestParameters.bTDocumentParams === undefined) {
            throw new runtime.RequiredError('bTDocumentParams','Required parameter requestParameters.bTDocumentParams was null or undefined when calling createDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentParamsToJSON(requestParameters.bTDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Create and upload a document.
     */
    async createDocument(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentInfo> {
        const response = await this.createDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create version by document ID.
     */
    async createVersionRaw(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTVersionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createVersion.');
        }

        if (requestParameters.bTVersionOrWorkspaceParams === null || requestParameters.bTVersionOrWorkspaceParams === undefined) {
            throw new runtime.RequiredError('bTVersionOrWorkspaceParams','Required parameter requestParameters.bTVersionOrWorkspaceParams was null or undefined when calling createVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceParamsToJSON(requestParameters.bTVersionOrWorkspaceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTVersionInfoFromJSON(jsonValue));
    }

    /**
     * Create version by document ID.
     */
    async createVersion(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTVersionInfo> {
        const response = await this.createVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create workspace by document ID.
     */
    async createWorkspaceRaw(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTWorkspaceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceParamsToJSON(requestParameters.bTVersionOrWorkspaceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTWorkspaceInfoFromJSON(jsonValue));
    }

    /**
     * Create workspace by document ID.
     */
    async createWorkspace(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTWorkspaceInfo> {
        const response = await this.createWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete document by document ID.
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.forever !== undefined) {
            queryParameters['forever'] = requestParameters.forever;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Delete"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete document by document ID.
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete workspace by document ID and workspace ID.
     */
    async deleteWorkspaceRaw(requestParameters: DeleteWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling deleteWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Delete"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces/{wid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete workspace by document ID and workspace ID.
     */
    async deleteWorkspace(requestParameters: DeleteWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve external data by document ID and foreign ID.
     */
    async downloadExternalDataRaw(requestParameters: DownloadExternalDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadExternalData.');
        }

        if (requestParameters.fid === null || requestParameters.fid === undefined) {
            throw new runtime.RequiredError('fid','Required parameter requestParameters.fid was null or undefined when calling downloadExternalData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/externaldata/{fid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"fid"}}`, encodeURIComponent(String(requestParameters.fid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Retrieve external data by document ID and foreign ID.
     */
    async downloadExternalData(requestParameters: DownloadExternalDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadExternalDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export document by document ID, workspace or version ID, and tab ID.
     */
    async export2JsonRaw(requestParameters: Export2JsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling export2Json.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling export2Json.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling export2Json.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling export2Json.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/e/{eid}/export`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTBExportModelParamsToJSON(requestParameters.bTBExportModelParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Export document by document ID, workspace or version ID, and tab ID.
     */
    async export2Json(requestParameters: Export2JsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.export2JsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve current microversion by document ID and workspace or version ID.
     */
    async getCurrentMicroversionRaw(requestParameters: GetCurrentMicroversionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMicroversionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getCurrentMicroversion.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling getCurrentMicroversion.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling getCurrentMicroversion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/currentmicroversion`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMicroversionInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve current microversion by document ID and workspace or version ID.
     */
    async getCurrentMicroversion(requestParameters: GetCurrentMicroversionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMicroversionInfo> {
        const response = await this.getCurrentMicroversionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve document by document ID.
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve document by document ID.
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentInfo> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve access control list by document ID.
     */
    async getDocumentAclRaw(requestParameters: GetDocumentAclRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAclInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentAcl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/acl`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAclInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve access control list by document ID.
     */
    async getDocumentAcl(requestParameters: GetDocumentAclRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAclInfo> {
        const response = await this.getDocumentAclRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve document history by document ID and workspace or microversion ID.
     */
    async getDocumentHistoryRaw(requestParameters: GetDocumentHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTDocumentHistoryInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentHistory.');
        }

        if (requestParameters.wm === null || requestParameters.wm === undefined) {
            throw new runtime.RequiredError('wm','Required parameter requestParameters.wm was null or undefined when calling getDocumentHistory.');
        }

        if (requestParameters.wmid === null || requestParameters.wmid === undefined) {
            throw new runtime.RequiredError('wmid','Required parameter requestParameters.wmid was null or undefined when calling getDocumentHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wm}/{wmid}/documenthistory`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wm"}}`, encodeURIComponent(String(requestParameters.wm))).replace(`{${"wmid"}}`, encodeURIComponent(String(requestParameters.wmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTDocumentHistoryInfoFromJSON));
    }

    /**
     * Retrieve document history by document ID and workspace or microversion ID.
     */
    async getDocumentHistory(requestParameters: GetDocumentHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTDocumentHistoryInfo>> {
        const response = await this.getDocumentHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Document permissions by document ID.
     */
    async getDocumentPermissionSetRaw(requestParameters: GetDocumentPermissionSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentPermissionSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/permissionset`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve Document permissions by document ID.
     */
    async getDocumentPermissionSet(requestParameters: GetDocumentPermissionSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getDocumentPermissionSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve versions by document ID.
     */
    async getDocumentVersionsRaw(requestParameters: GetDocumentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTVersionInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTVersionInfoFromJSON));
    }

    /**
     * Retrieve versions by document ID.
     */
    async getDocumentVersions(requestParameters: GetDocumentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTVersionInfo>> {
        const response = await this.getDocumentVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve workspaces by document ID.
     */
    async getDocumentWorkspacesRaw(requestParameters: GetDocumentWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTWorkspaceInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentWorkspaces.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTWorkspaceInfoFromJSON));
    }

    /**
     * Retrieve workspaces by document ID.
     */
    async getDocumentWorkspaces(requestParameters: GetDocumentWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTWorkspaceInfo>> {
        const response = await this.getDocumentWorkspacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a document.
     */
    async getDocumentsRaw(requestParameters: GetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGlobalTreeNodeListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.owner !== undefined) {
            queryParameters['owner'] = requestParameters.owner;
        }

        if (requestParameters.ownerType !== undefined) {
            queryParameters['ownerType'] = requestParameters.ownerType;
        }

        if (requestParameters.sortColumn !== undefined) {
            queryParameters['sortColumn'] = requestParameters.sortColumn;
        }

        if (requestParameters.sortOrder !== undefined) {
            queryParameters['sortOrder'] = requestParameters.sortOrder;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.project !== undefined) {
            queryParameters['project'] = requestParameters.project;
        }

        if (requestParameters.parentId !== undefined) {
            queryParameters['parentId'] = requestParameters.parentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGlobalTreeNodeListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a document.
     */
    async getDocuments(requestParameters: GetDocumentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGlobalTreeNodeListResponse> {
        const response = await this.getDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve tabs by document ID and workspace or version or microversion ID.
     */
    async getElementsInDocumentRaw(requestParameters: GetElementsInDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTDocumentElementInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getElementsInDocument.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getElementsInDocument.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getElementsInDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.elementType !== undefined) {
            queryParameters['elementType'] = requestParameters.elementType;
        }

        if (requestParameters.elementId !== undefined) {
            queryParameters['elementId'] = requestParameters.elementId;
        }

        if (requestParameters.withThumbnails !== undefined) {
            queryParameters['withThumbnails'] = requestParameters.withThumbnails;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wvm}/{wvmid}/elements`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTDocumentElementInfoFromJSON));
    }

    /**
     * Retrieve tabs by document ID and workspace or version or microversion ID.
     */
    async getElementsInDocument(requestParameters: GetElementsInDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTDocumentElementInfo>> {
        const response = await this.getElementsInDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve insertables by document ID and workspace or version ID.
     */
    async getInsertablesRaw(requestParameters: GetInsertablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTInsertablesListResponse>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getInsertables.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling getInsertables.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling getInsertables.');
        }

        const queryParameters: any = {};

        if (requestParameters.elementId !== undefined) {
            queryParameters['elementId'] = requestParameters.elementId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.betaCapabilityIds) {
            queryParameters['betaCapabilityIds'] = requestParameters.betaCapabilityIds;
        }

        if (requestParameters.includeParts !== undefined) {
            queryParameters['includeParts'] = requestParameters.includeParts;
        }

        if (requestParameters.includeSurfaces !== undefined) {
            queryParameters['includeSurfaces'] = requestParameters.includeSurfaces;
        }

        if (requestParameters.includeSketches !== undefined) {
            queryParameters['includeSketches'] = requestParameters.includeSketches;
        }

        if (requestParameters.includeReferenceFeatures !== undefined) {
            queryParameters['includeReferenceFeatures'] = requestParameters.includeReferenceFeatures;
        }

        if (requestParameters.includeAssemblies !== undefined) {
            queryParameters['includeAssemblies'] = requestParameters.includeAssemblies;
        }

        if (requestParameters.includeFeatureStudios !== undefined) {
            queryParameters['includeFeatureStudios'] = requestParameters.includeFeatureStudios;
        }

        if (requestParameters.includeBlobs !== undefined) {
            queryParameters['includeBlobs'] = requestParameters.includeBlobs;
        }

        if (requestParameters.allowedBlobMimeTypes !== undefined) {
            queryParameters['allowedBlobMimeTypes'] = requestParameters.allowedBlobMimeTypes;
        }

        if (requestParameters.excludeNewerFSVersions !== undefined) {
            queryParameters['excludeNewerFSVersions'] = requestParameters.excludeNewerFSVersions;
        }

        if (requestParameters.maxFeatureScriptVersion !== undefined) {
            queryParameters['maxFeatureScriptVersion'] = requestParameters.maxFeatureScriptVersion;
        }

        if (requestParameters.includePartStudios !== undefined) {
            queryParameters['includePartStudios'] = requestParameters.includePartStudios;
        }

        if (requestParameters.includeFeatures !== undefined) {
            queryParameters['includeFeatures'] = requestParameters.includeFeatures;
        }

        if (requestParameters.includeMeshes !== undefined) {
            queryParameters['includeMeshes'] = requestParameters.includeMeshes;
        }

        if (requestParameters.includeWires !== undefined) {
            queryParameters['includeWires'] = requestParameters.includeWires;
        }

        if (requestParameters.includeFlattenedBodies !== undefined) {
            queryParameters['includeFlattenedBodies'] = requestParameters.includeFlattenedBodies;
        }

        if (requestParameters.includeApplications !== undefined) {
            queryParameters['includeApplications'] = requestParameters.includeApplications;
        }

        if (requestParameters.allowedApplicationMimeTypes !== undefined) {
            queryParameters['allowedApplicationMimeTypes'] = requestParameters.allowedApplicationMimeTypes;
        }

        if (requestParameters.includeCompositeParts !== undefined) {
            queryParameters['includeCompositeParts'] = requestParameters.includeCompositeParts;
        }

        if (requestParameters.includeFSTables !== undefined) {
            queryParameters['includeFSTables'] = requestParameters.includeFSTables;
        }

        if (requestParameters.includeFSComputedPartPropertyFunctions !== undefined) {
            queryParameters['includeFSComputedPartPropertyFunctions'] = requestParameters.includeFSComputedPartPropertyFunctions;
        }

        if (requestParameters.includeVariables !== undefined) {
            queryParameters['includeVariables'] = requestParameters.includeVariables;
        }

        if (requestParameters.includeVariableStudios !== undefined) {
            queryParameters['includeVariableStudios'] = requestParameters.includeVariableStudios;
        }

        if (requestParameters.allowedBlobExtensions !== undefined) {
            queryParameters['allowedBlobExtensions'] = requestParameters.allowedBlobExtensions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/insertables`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTInsertablesListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve insertables by document ID and workspace or version ID.
     */
    async getInsertables(requestParameters: GetInsertablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTInsertablesListResponse> {
        const response = await this.getInsertablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the selected units and precision by document ID and workspace or version or microversion ID.
     */
    async getUnitInfoRaw(requestParameters: GetUnitInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTUnitInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getUnitInfo.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getUnitInfo.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getUnitInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wvm}/{wvmid}/unitinfo`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTUnitInfoFromJSON(jsonValue));
    }

    /**
     * Get the selected units and precision by document ID and workspace or version or microversion ID.
     */
    async getUnitInfo(requestParameters: GetUnitInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTUnitInfo> {
        const response = await this.getUnitInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve version by document ID and version ID.
     */
    async getVersionRaw(requestParameters: GetVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTVersionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getVersion.');
        }

        if (requestParameters.vid === null || requestParameters.vid === undefined) {
            throw new runtime.RequiredError('vid','Required parameter requestParameters.vid was null or undefined when calling getVersion.');
        }

        const queryParameters: any = {};

        if (requestParameters.parents !== undefined) {
            queryParameters['parents'] = requestParameters.parents;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions/{vid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"vid"}}`, encodeURIComponent(String(requestParameters.vid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTVersionInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve version by document ID and version ID.
     */
    async getVersion(requestParameters: GetVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTVersionInfo> {
        const response = await this.getVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge into workspace by document ID and workspace ID.
     */
    async mergeIntoWorkspaceRaw(requestParameters: MergeIntoWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentMergeInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling mergeIntoWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling mergeIntoWorkspace.');
        }

        if (requestParameters.bTVersionOrWorkspaceMergeInfo === null || requestParameters.bTVersionOrWorkspaceMergeInfo === undefined) {
            throw new runtime.RequiredError('bTVersionOrWorkspaceMergeInfo','Required parameter requestParameters.bTVersionOrWorkspaceMergeInfo was null or undefined when calling mergeIntoWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/workspaces/{wid}/merge`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceMergeInfoToJSON(requestParameters.bTVersionOrWorkspaceMergeInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentMergeInfoFromJSON(jsonValue));
    }

    /**
     * Merge into workspace by document ID and workspace ID.
     */
    async mergeIntoWorkspace(requestParameters: MergeIntoWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentMergeInfo> {
        const response = await this.mergeIntoWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID
     */
    async mergePreviewRaw(requestParameters: MergePreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMergePreviewInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling mergePreview.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling mergePreview.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling mergePreview.');
        }

        if (requestParameters.sourceId === null || requestParameters.sourceId === undefined) {
            throw new runtime.RequiredError('sourceId','Required parameter requestParameters.sourceId was null or undefined when calling mergePreview.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.sourceType !== undefined) {
            queryParameters['sourceType'] = requestParameters.sourceType;
        }

        if (requestParameters.sourceId !== undefined) {
            queryParameters['sourceId'] = requestParameters.sourceId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/w/{wid}/mergePreview`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMergePreviewInfoFromJSON(jsonValue));
    }

    /**
     * Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID
     */
    async mergePreview(requestParameters: MergePreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMergePreviewInfo> {
        const response = await this.mergePreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move tab by document ID and workspace ID.
     */
    async moveElementsToDocumentRaw(requestParameters: MoveElementsToDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMoveElementInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling moveElementsToDocument.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling moveElementsToDocument.');
        }

        if (requestParameters.bTMoveElementParams === null || requestParameters.bTMoveElementParams === undefined) {
            throw new runtime.RequiredError('bTMoveElementParams','Required parameter requestParameters.bTMoveElementParams was null or undefined when calling moveElementsToDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/moveelement`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTMoveElementParamsToJSON(requestParameters.bTMoveElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMoveElementInfoFromJSON(jsonValue));
    }

    /**
     * Move tab by document ID and workspace ID.
     */
    async moveElementsToDocument(requestParameters: MoveElementsToDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMoveElementInfo> {
        const response = await this.moveElementsToDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.
     */
    async restoreFromHistoryRaw(requestParameters: RestoreFromHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTRestoreFromHistoryInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.vm === null || requestParameters.vm === undefined) {
            throw new runtime.RequiredError('vm','Required parameter requestParameters.vm was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.vmid === null || requestParameters.vmid === undefined) {
            throw new runtime.RequiredError('vmid','Required parameter requestParameters.vmid was null or undefined when calling restoreFromHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/w/{wid}/restore/{vm}/{vmid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"vm"}}`, encodeURIComponent(String(requestParameters.vm))).replace(`{${"vmid"}}`, encodeURIComponent(String(requestParameters.vmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTRestoreFromHistoryInfoFromJSON(jsonValue));
    }

    /**
     * Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.
     */
    async restoreFromHistory(requestParameters: RestoreFromHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTRestoreFromHistoryInfo> {
        const response = await this.restoreFromHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async revertUnchangedToRevisionsRaw(requestParameters: RevertUnchangedToRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTUnchangedElementInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling revertUnchangedToRevisions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling revertUnchangedToRevisions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/revertunchangedtorevisions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTRevertUnchangedParamsToJSON(requestParameters.bTRevertUnchangedParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTUnchangedElementInfoFromJSON));
    }

    /**
     */
    async revertUnchangedToRevisions(requestParameters: RevertUnchangedToRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTUnchangedElementInfo>> {
        const response = await this.revertUnchangedToRevisionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This returns list of documents based on search parameters.
     * Search document.
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.bTDocumentSearchParams === null || requestParameters.bTDocumentSearchParams === undefined) {
            throw new runtime.RequiredError('bTDocumentSearchParams','Required parameter requestParameters.bTDocumentSearchParams was null or undefined when calling search.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentSearchParamsToJSON(requestParameters.bTDocumentSearchParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This returns list of documents based on search parameters.
     * Search document.
     */
    async search(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Share document by document ID.
     */
    async shareDocumentRaw(requestParameters: ShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAclInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling shareDocument.');
        }

        if (requestParameters.bTShareParams === null || requestParameters.bTShareParams === undefined) {
            throw new runtime.RequiredError('bTShareParams','Required parameter requestParameters.bTShareParams was null or undefined when calling shareDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Share"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/share`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTShareParamsToJSON(requestParameters.bTShareParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAclInfoFromJSON(jsonValue));
    }

    /**
     * Share document by document ID.
     */
    async shareDocument(requestParameters: ShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAclInfo> {
        const response = await this.shareDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Share document by document ID with Onshape support.
     */
    async shareWithSupportRaw(requestParameters: ShareWithSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling shareWithSupport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/shareWithSupport`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Share document by document ID with Onshape support.
     */
    async shareWithSupport(requestParameters: ShareWithSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.shareWithSupportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async syncApplicationElementsRaw(requestParameters: SyncApplicationElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling syncApplicationElements.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling syncApplicationElements.');
        }

        if (requestParameters.bTSyncAppElementParams === null || requestParameters.bTSyncAppElementParams === undefined) {
            throw new runtime.RequiredError('bTSyncAppElementParams','Required parameter requestParameters.bTSyncAppElementParams was null or undefined when calling syncApplicationElements.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/syncAppElements`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTSyncAppElementParamsToJSON(requestParameters.bTSyncAppElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     */
    async syncApplicationElements(requestParameters: SyncApplicationElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.syncApplicationElementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unshare document by document ID and tab ID.
     */
    async unShareDocumentRaw(requestParameters: UnShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling unShareDocument.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling unShareDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.entryType !== undefined) {
            queryParameters['entryType'] = requestParameters.entryType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Share"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/share/{eid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unshare document by document ID and tab ID.
     */
    async unShareDocument(requestParameters: UnShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unShareDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unshare document with support.
     */
    async unshareFromSupportRaw(requestParameters: UnshareFromSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling unshareFromSupport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/shareWithSupport`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unshare document with support.
     */
    async unshareFromSupport(requestParameters: UnshareFromSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unshareFromSupportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update document attributes by document ID.
     */
    async updateDocumentAttributesRaw(requestParameters: UpdateDocumentAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateDocumentAttributes.');
        }

        if (requestParameters.bTDocumentParams === null || requestParameters.bTDocumentParams === undefined) {
            throw new runtime.RequiredError('bTDocumentParams','Required parameter requestParameters.bTDocumentParams was null or undefined when calling updateDocumentAttributes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentParamsToJSON(requestParameters.bTDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Update document attributes by document ID.
     */
    async updateDocumentAttributes(requestParameters: UpdateDocumentAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateDocumentAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update external references to latest by document ID, workspace ID, and tab ID.
     */
    async updateExternalReferencesToLatestDocumentsRaw(requestParameters: UpdateExternalReferencesToLatestDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTLinkToLatestDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTLinkToLatestDocumentParamsToJSON(requestParameters.bTLinkToLatestDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTLinkToLatestDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Update external references to latest by document ID, workspace ID, and tab ID.
     */
    async updateExternalReferencesToLatestDocuments(requestParameters: UpdateExternalReferencesToLatestDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTLinkToLatestDocumentInfo> {
        const response = await this.updateExternalReferencesToLatestDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const Export2JsonWvEnum = {
    W: 'w',
    V: 'v'
} as const;
export type Export2JsonWvEnum = typeof Export2JsonWvEnum[keyof typeof Export2JsonWvEnum];
/**
 * @export
 */
export const GetElementsInDocumentWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetElementsInDocumentWvmEnum = typeof GetElementsInDocumentWvmEnum[keyof typeof GetElementsInDocumentWvmEnum];
/**
 * @export
 */
export const GetUnitInfoWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetUnitInfoWvmEnum = typeof GetUnitInfoWvmEnum[keyof typeof GetUnitInfoWvmEnum];
