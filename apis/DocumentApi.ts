/* tslint:disable */
/* eslint-disable */
/**
 * Onshape REST API
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn\'t used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.196.54436-927372740f35
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTACLPublicParams,
  BTAclInfo,
  BTAclParams,
  BTBExportModelParams,
  BTCopyDocumentInfo,
  BTCopyDocumentParams,
  BTDocumentElementInfo,
  BTDocumentHistoryInfo,
  BTDocumentInfo,
  BTDocumentMergeInfo,
  BTDocumentParams,
  BTDocumentSearchParams,
  BTDocumentSummaryInfo,
  BTGlobalTreeNodeListResponse,
  BTInsertablesListResponse,
  BTLinkToLatestDocumentInfo,
  BTLinkToLatestDocumentParams,
  BTMergePreviewInfo,
  BTMicroversionInfo,
  BTMoveElementInfo,
  BTMoveElementParams,
  BTRestoreFromHistoryInfo,
  BTRestoreInfo,
  BTRevertUnchangedParams,
  BTShareParams,
  BTSyncAppElementParams,
  BTUnchangedElementInfo,
  BTUnitInfo,
  BTVersionInfo,
  BTVersionOrWorkspaceMergeInfo,
  BTVersionOrWorkspaceParams,
  BTWorkspaceInfo,
} from '../models';
import {
    BTACLPublicParamsFromJSON,
    BTACLPublicParamsToJSON,
    BTAclInfoFromJSON,
    BTAclInfoToJSON,
    BTAclParamsFromJSON,
    BTAclParamsToJSON,
    BTBExportModelParamsFromJSON,
    BTBExportModelParamsToJSON,
    BTCopyDocumentInfoFromJSON,
    BTCopyDocumentInfoToJSON,
    BTCopyDocumentParamsFromJSON,
    BTCopyDocumentParamsToJSON,
    BTDocumentElementInfoFromJSON,
    BTDocumentElementInfoToJSON,
    BTDocumentHistoryInfoFromJSON,
    BTDocumentHistoryInfoToJSON,
    BTDocumentInfoFromJSON,
    BTDocumentInfoToJSON,
    BTDocumentMergeInfoFromJSON,
    BTDocumentMergeInfoToJSON,
    BTDocumentParamsFromJSON,
    BTDocumentParamsToJSON,
    BTDocumentSearchParamsFromJSON,
    BTDocumentSearchParamsToJSON,
    BTDocumentSummaryInfoFromJSON,
    BTDocumentSummaryInfoToJSON,
    BTGlobalTreeNodeListResponseFromJSON,
    BTGlobalTreeNodeListResponseToJSON,
    BTInsertablesListResponseFromJSON,
    BTInsertablesListResponseToJSON,
    BTLinkToLatestDocumentInfoFromJSON,
    BTLinkToLatestDocumentInfoToJSON,
    BTLinkToLatestDocumentParamsFromJSON,
    BTLinkToLatestDocumentParamsToJSON,
    BTMergePreviewInfoFromJSON,
    BTMergePreviewInfoToJSON,
    BTMicroversionInfoFromJSON,
    BTMicroversionInfoToJSON,
    BTMoveElementInfoFromJSON,
    BTMoveElementInfoToJSON,
    BTMoveElementParamsFromJSON,
    BTMoveElementParamsToJSON,
    BTRestoreFromHistoryInfoFromJSON,
    BTRestoreFromHistoryInfoToJSON,
    BTRestoreInfoFromJSON,
    BTRestoreInfoToJSON,
    BTRevertUnchangedParamsFromJSON,
    BTRevertUnchangedParamsToJSON,
    BTShareParamsFromJSON,
    BTShareParamsToJSON,
    BTSyncAppElementParamsFromJSON,
    BTSyncAppElementParamsToJSON,
    BTUnchangedElementInfoFromJSON,
    BTUnchangedElementInfoToJSON,
    BTUnitInfoFromJSON,
    BTUnitInfoToJSON,
    BTVersionInfoFromJSON,
    BTVersionInfoToJSON,
    BTVersionOrWorkspaceMergeInfoFromJSON,
    BTVersionOrWorkspaceMergeInfoToJSON,
    BTVersionOrWorkspaceParamsFromJSON,
    BTVersionOrWorkspaceParamsToJSON,
    BTWorkspaceInfoFromJSON,
    BTWorkspaceInfoToJSON,
} from '../models';

export interface CopyWorkspaceRequest {
    did: string;
    wid: string;
    bTCopyDocumentParams: BTCopyDocumentParams;
}

export interface CreateDocumentRequest {
    bTDocumentParams: BTDocumentParams;
}

export interface CreateVersionRequest {
    did: string;
    bTVersionOrWorkspaceParams: BTVersionOrWorkspaceParams;
}

export interface CreateWorkspaceRequest {
    did: string;
    bTVersionOrWorkspaceParams?: BTVersionOrWorkspaceParams;
}

export interface DeleteDocumentRequest {
    did: string;
    forever?: boolean;
}

export interface DeleteWorkspaceRequest {
    did: string;
    wid: string;
}

export interface DownloadExternalDataRequest {
    did: string;
    fid: string;
    ifNoneMatch?: string;
}

export interface Export2JsonRequest {
    did: string;
    wv: Export2JsonWvEnum;
    wvid: string;
    eid: string;
    linkDocumentId?: string;
    bTBExportModelParams?: BTBExportModelParams;
}

export interface GetCurrentMicroversionRequest {
    did: string;
    wv: string;
    wvid: string;
}

export interface GetDocumentRequest {
    did: string;
}

export interface GetDocumentAclRequest {
    did: string;
}

export interface GetDocumentHistoryRequest {
    did: string;
    wm: string;
    wmid: string;
}

export interface GetDocumentPermissionSetRequest {
    did: string;
}

export interface GetDocumentVersionsRequest {
    did: string;
    offset?: number;
    limit?: number;
}

export interface GetDocumentWorkspacesRequest {
    did: string;
}

export interface GetDocumentsRequest {
    q?: string;
    filter?: number;
    owner?: string;
    ownerType?: number;
    sortColumn?: string;
    sortOrder?: string;
    offset?: number;
    limit?: number;
    label?: string;
    project?: string;
    parentId?: string;
}

export interface GetElementsInDocumentRequest {
    did: string;
    wvm: GetElementsInDocumentWvmEnum;
    wvmid: string;
    linkDocumentId?: string;
    elementType?: string;
    elementId?: string;
    withThumbnails?: boolean;
}

export interface GetInsertablesRequest {
    did: string;
    wv: string;
    wvid: string;
    elementId?: string;
    _configuration?: string;
    linkDocumentId?: string;
    includeParts?: boolean;
    includeSurfaces?: boolean;
    includeSketches?: boolean;
    includeReferenceFeatures?: boolean;
    includeAssemblies?: boolean;
    includeFeatureStudios?: boolean;
    includeBlobs?: boolean;
    allowedBlobMimeTypes?: string;
    excludeNewerFSVersions?: boolean;
    maxFeatureScriptVersion?: number;
    includePartStudios?: boolean;
    includeFeatures?: boolean;
    includeMeshes?: boolean;
    includeWires?: boolean;
    includeFlattenedBodies?: boolean;
    includeApplications?: boolean;
    allowedApplicationMimeTypes?: string;
    includeCompositeParts?: boolean;
    includeFSTables?: boolean;
    includeFSComputedPartPropertyFunctions?: boolean;
    includeVariables?: boolean;
    includeVariableStudios?: boolean;
    allowedBlobExtensions?: string;
}

export interface GetInsertablesQueryRequest {
    offset?: number;
    limit?: number;
    q?: string;
    filter?: number;
    owner?: string;
    getPathToRoot?: boolean;
    includeParts?: boolean;
    includeSurfaces?: boolean;
    includeSketches?: boolean;
    includeReferenceFeatures?: boolean;
    includeAssemblies?: boolean;
    includeFeatureStudios?: boolean;
    includeBlobs?: boolean;
    allowedBlobMimeTypes?: string;
    includePartStudios?: boolean;
    includeFeatures?: boolean;
    includeWires?: boolean;
    includeFlattenedBodies?: boolean;
    includeApplications?: boolean;
    allowedApplicationMimeTypes?: string;
    includeFSTables?: boolean;
    includeFSComputedPartPropertyFunctions?: boolean;
    includeVariables?: boolean;
    includeVariableStudios?: boolean;
    allowedBlobExtensions?: string;
}

export interface GetUnitInfoRequest {
    did: string;
    wvm: GetUnitInfoWvmEnum;
    wvmid: string;
    linkDocumentId?: string;
}

export interface GetVersionRequest {
    did: string;
    vid: string;
    parents?: boolean;
    linkDocumentId?: string;
}

export interface MakeDocumentPublicRequest {
    did: string;
    bTACLPublicParams: BTACLPublicParams;
}

export interface MergeIntoWorkspaceRequest {
    did: string;
    wid: string;
    bTVersionOrWorkspaceMergeInfo: BTVersionOrWorkspaceMergeInfo;
}

export interface MergePreviewRequest {
    did: string;
    wid: string;
    sourceType: string;
    sourceId: string;
    linkDocumentId?: string;
}

export interface MoveElementsToDocumentRequest {
    did: string;
    wid: string;
    bTMoveElementParams: BTMoveElementParams;
}

export interface RestoreFromHistoryRequest {
    did: string;
    wid: string;
    vm: string;
    vmid: string;
    linkDocumentId?: string;
    bTRestoreInfo?: BTRestoreInfo;
}

export interface RevertUnchangedToRevisionsRequest {
    did: string;
    wid: string;
    bTRevertUnchangedParams?: BTRevertUnchangedParams;
}

export interface SearchRequest {
    bTDocumentSearchParams: BTDocumentSearchParams;
}

export interface ShareDocumentRequest {
    did: string;
    bTShareParams: BTShareParams;
}

export interface ShareWithSupportRequest {
    did: string;
}

export interface SyncAppElementsRequest {
    did: string;
    wid: string;
    bTSyncAppElementParams: BTSyncAppElementParams;
}

export interface UnShareDocumentRequest {
    did: string;
    eid: string;
    entryType?: number;
}

export interface UnshareFromSupportRequest {
    did: string;
}

export interface UpdateAnonymousAccessRequest {
    did: string;
    bTAclParams: BTAclParams;
}

export interface UpdateDocumentAttributesRequest {
    did: string;
    bTDocumentParams: BTDocumentParams;
}

export interface UpdateExternalReferencesToLatestDocumentsRequest {
    did: string;
    wid: string;
    eid: string;
    bTLinkToLatestDocumentParams?: BTLinkToLatestDocumentParams;
}

/**
 * 
 */
export class DocumentApi extends runtime.BaseAPI {

    /**
     * Copy workspace by document ID and workspace ID.
     */
    async copyWorkspaceRaw(requestParameters: CopyWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTCopyDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling copyWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling copyWorkspace.');
        }

        if (requestParameters.bTCopyDocumentParams === null || requestParameters.bTCopyDocumentParams === undefined) {
            throw new runtime.RequiredError('bTCopyDocumentParams','Required parameter requestParameters.bTCopyDocumentParams was null or undefined when calling copyWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/workspaces/{wid}/copy`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTCopyDocumentParamsToJSON(requestParameters.bTCopyDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTCopyDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Copy workspace by document ID and workspace ID.
     */
    async copyWorkspace(requestParameters: CopyWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTCopyDocumentInfo> {
        const response = await this.copyWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The `name` field is required in the `BTDocumentParams` schema when creating a new document.
     * Create and upload a document.
     */
    async createDocumentRaw(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentInfo>> {
        if (requestParameters.bTDocumentParams === null || requestParameters.bTDocumentParams === undefined) {
            throw new runtime.RequiredError('bTDocumentParams','Required parameter requestParameters.bTDocumentParams was null or undefined when calling createDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentParamsToJSON(requestParameters.bTDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentInfoFromJSON(jsonValue));
    }

    /**
     * The `name` field is required in the `BTDocumentParams` schema when creating a new document.
     * Create and upload a document.
     */
    async createDocument(requestParameters: CreateDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentInfo> {
        const response = await this.createDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create version by document ID.
     */
    async createVersionRaw(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTVersionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createVersion.');
        }

        if (requestParameters.bTVersionOrWorkspaceParams === null || requestParameters.bTVersionOrWorkspaceParams === undefined) {
            throw new runtime.RequiredError('bTVersionOrWorkspaceParams','Required parameter requestParameters.bTVersionOrWorkspaceParams was null or undefined when calling createVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceParamsToJSON(requestParameters.bTVersionOrWorkspaceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTVersionInfoFromJSON(jsonValue));
    }

    /**
     * Create version by document ID.
     */
    async createVersion(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTVersionInfo> {
        const response = await this.createVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create workspace by document ID.
     */
    async createWorkspaceRaw(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTWorkspaceInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling createWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceParamsToJSON(requestParameters.bTVersionOrWorkspaceParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTWorkspaceInfoFromJSON(jsonValue));
    }

    /**
     * Create workspace by document ID.
     */
    async createWorkspace(requestParameters: CreateWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTWorkspaceInfo> {
        const response = await this.createWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete document by document ID.
     */
    async deleteDocumentRaw(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.forever !== undefined) {
            queryParameters['forever'] = requestParameters.forever;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Delete"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete document by document ID.
     */
    async deleteDocument(requestParameters: DeleteDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete workspace by document ID and workspace ID.
     */
    async deleteWorkspaceRaw(requestParameters: DeleteWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling deleteWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling deleteWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Delete"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces/{wid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Delete workspace by document ID and workspace ID.
     */
    async deleteWorkspace(requestParameters: DeleteWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.deleteWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details. * If downloading an exported file, poll the `requestState` in the translation response and wait for a result of `DONE` before attempting to download the file.  * Use the `resultExternalDataIds` from the translation response as the foreign id (`{fid}`) in this API.
     * Download external data file(s) associated with the document.
     */
    async downloadExternalDataRaw(requestParameters: DownloadExternalDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling downloadExternalData.');
        }

        if (requestParameters.fid === null || requestParameters.fid === undefined) {
            throw new runtime.RequiredError('fid','Required parameter requestParameters.fid was null or undefined when calling downloadExternalData.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.ifNoneMatch !== undefined && requestParameters.ifNoneMatch !== null) {
            headerParameters['If-None-Match'] = String(requestParameters.ifNoneMatch);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/externaldata/{fid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"fid"}}`, encodeURIComponent(String(requestParameters.fid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details. * If downloading an exported file, poll the `requestState` in the translation response and wait for a result of `DONE` before attempting to download the file.  * Use the `resultExternalDataIds` from the translation response as the foreign id (`{fid}`) in this API.
     * Download external data file(s) associated with the document.
     */
    async downloadExternalData(requestParameters: DownloadExternalDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.downloadExternalDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export document by document ID, workspace or version ID, and tab ID.
     */
    async export2JsonRaw(requestParameters: Export2JsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling export2Json.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling export2Json.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling export2Json.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling export2Json.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/e/{eid}/export`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTBExportModelParamsToJSON(requestParameters.bTBExportModelParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Export document by document ID, workspace or version ID, and tab ID.
     */
    async export2Json(requestParameters: Export2JsonRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.export2JsonRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve current microversion by document ID and workspace or version ID.
     */
    async getCurrentMicroversionRaw(requestParameters: GetCurrentMicroversionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMicroversionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getCurrentMicroversion.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling getCurrentMicroversion.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling getCurrentMicroversion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/currentmicroversion`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMicroversionInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve current microversion by document ID and workspace or version ID.
     */
    async getCurrentMicroversion(requestParameters: GetCurrentMicroversionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMicroversionInfo> {
        const response = await this.getCurrentMicroversionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve document by document ID.
     */
    async getDocumentRaw(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve document by document ID.
     */
    async getDocument(requestParameters: GetDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentInfo> {
        const response = await this.getDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve access control list by document ID.
     */
    async getDocumentAclRaw(requestParameters: GetDocumentAclRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAclInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentAcl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/acl`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAclInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve access control list by document ID.
     */
    async getDocumentAcl(requestParameters: GetDocumentAclRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAclInfo> {
        const response = await this.getDocumentAclRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve document history by document ID and workspace or microversion ID.
     */
    async getDocumentHistoryRaw(requestParameters: GetDocumentHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTDocumentHistoryInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentHistory.');
        }

        if (requestParameters.wm === null || requestParameters.wm === undefined) {
            throw new runtime.RequiredError('wm','Required parameter requestParameters.wm was null or undefined when calling getDocumentHistory.');
        }

        if (requestParameters.wmid === null || requestParameters.wmid === undefined) {
            throw new runtime.RequiredError('wmid','Required parameter requestParameters.wmid was null or undefined when calling getDocumentHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wm}/{wmid}/documenthistory`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wm"}}`, encodeURIComponent(String(requestParameters.wm))).replace(`{${"wmid"}}`, encodeURIComponent(String(requestParameters.wmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTDocumentHistoryInfoFromJSON));
    }

    /**
     * Retrieve document history by document ID and workspace or microversion ID.
     */
    async getDocumentHistory(requestParameters: GetDocumentHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTDocumentHistoryInfo>> {
        const response = await this.getDocumentHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Document permissions by document ID.
     */
    async getDocumentPermissionSetRaw(requestParameters: GetDocumentPermissionSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentPermissionSet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/permissionset`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Retrieve Document permissions by document ID.
     */
    async getDocumentPermissionSet(requestParameters: GetDocumentPermissionSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getDocumentPermissionSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve versions by document ID.
     */
    async getDocumentVersionsRaw(requestParameters: GetDocumentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTVersionInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTVersionInfoFromJSON));
    }

    /**
     * Retrieve versions by document ID.
     */
    async getDocumentVersions(requestParameters: GetDocumentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTVersionInfo>> {
        const response = await this.getDocumentVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve workspaces by document ID.
     */
    async getDocumentWorkspacesRaw(requestParameters: GetDocumentWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTWorkspaceInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getDocumentWorkspaces.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/workspaces`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTWorkspaceInfoFromJSON));
    }

    /**
     * Retrieve workspaces by document ID.
     */
    async getDocumentWorkspaces(requestParameters: GetDocumentWorkspacesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTWorkspaceInfo>> {
        const response = await this.getDocumentWorkspacesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of documents that meet the criteria you specify.
     */
    async getDocumentsRaw(requestParameters: GetDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGlobalTreeNodeListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.owner !== undefined) {
            queryParameters['owner'] = requestParameters.owner;
        }

        if (requestParameters.ownerType !== undefined) {
            queryParameters['ownerType'] = requestParameters.ownerType;
        }

        if (requestParameters.sortColumn !== undefined) {
            queryParameters['sortColumn'] = requestParameters.sortColumn;
        }

        if (requestParameters.sortOrder !== undefined) {
            queryParameters['sortOrder'] = requestParameters.sortOrder;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.project !== undefined) {
            queryParameters['project'] = requestParameters.project;
        }

        if (requestParameters.parentId !== undefined) {
            queryParameters['parentId'] = requestParameters.parentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGlobalTreeNodeListResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of documents that meet the criteria you specify.
     */
    async getDocuments(requestParameters: GetDocumentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGlobalTreeNodeListResponse> {
        const response = await this.getDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve tabs by document ID and workspace or version or microversion ID.
     */
    async getElementsInDocumentRaw(requestParameters: GetElementsInDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTDocumentElementInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getElementsInDocument.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getElementsInDocument.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getElementsInDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.elementType !== undefined) {
            queryParameters['elementType'] = requestParameters.elementType;
        }

        if (requestParameters.elementId !== undefined) {
            queryParameters['elementId'] = requestParameters.elementId;
        }

        if (requestParameters.withThumbnails !== undefined) {
            queryParameters['withThumbnails'] = requestParameters.withThumbnails;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wvm}/{wvmid}/elements`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTDocumentElementInfoFromJSON));
    }

    /**
     * Retrieve tabs by document ID and workspace or version or microversion ID.
     */
    async getElementsInDocument(requestParameters: GetElementsInDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTDocumentElementInfo>> {
        const response = await this.getElementsInDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve insertables by document ID and workspace or version ID.
     */
    async getInsertablesRaw(requestParameters: GetInsertablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTInsertablesListResponse>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getInsertables.');
        }

        if (requestParameters.wv === null || requestParameters.wv === undefined) {
            throw new runtime.RequiredError('wv','Required parameter requestParameters.wv was null or undefined when calling getInsertables.');
        }

        if (requestParameters.wvid === null || requestParameters.wvid === undefined) {
            throw new runtime.RequiredError('wvid','Required parameter requestParameters.wvid was null or undefined when calling getInsertables.');
        }

        const queryParameters: any = {};

        if (requestParameters.elementId !== undefined) {
            queryParameters['elementId'] = requestParameters.elementId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.includeParts !== undefined) {
            queryParameters['includeParts'] = requestParameters.includeParts;
        }

        if (requestParameters.includeSurfaces !== undefined) {
            queryParameters['includeSurfaces'] = requestParameters.includeSurfaces;
        }

        if (requestParameters.includeSketches !== undefined) {
            queryParameters['includeSketches'] = requestParameters.includeSketches;
        }

        if (requestParameters.includeReferenceFeatures !== undefined) {
            queryParameters['includeReferenceFeatures'] = requestParameters.includeReferenceFeatures;
        }

        if (requestParameters.includeAssemblies !== undefined) {
            queryParameters['includeAssemblies'] = requestParameters.includeAssemblies;
        }

        if (requestParameters.includeFeatureStudios !== undefined) {
            queryParameters['includeFeatureStudios'] = requestParameters.includeFeatureStudios;
        }

        if (requestParameters.includeBlobs !== undefined) {
            queryParameters['includeBlobs'] = requestParameters.includeBlobs;
        }

        if (requestParameters.allowedBlobMimeTypes !== undefined) {
            queryParameters['allowedBlobMimeTypes'] = requestParameters.allowedBlobMimeTypes;
        }

        if (requestParameters.excludeNewerFSVersions !== undefined) {
            queryParameters['excludeNewerFSVersions'] = requestParameters.excludeNewerFSVersions;
        }

        if (requestParameters.maxFeatureScriptVersion !== undefined) {
            queryParameters['maxFeatureScriptVersion'] = requestParameters.maxFeatureScriptVersion;
        }

        if (requestParameters.includePartStudios !== undefined) {
            queryParameters['includePartStudios'] = requestParameters.includePartStudios;
        }

        if (requestParameters.includeFeatures !== undefined) {
            queryParameters['includeFeatures'] = requestParameters.includeFeatures;
        }

        if (requestParameters.includeMeshes !== undefined) {
            queryParameters['includeMeshes'] = requestParameters.includeMeshes;
        }

        if (requestParameters.includeWires !== undefined) {
            queryParameters['includeWires'] = requestParameters.includeWires;
        }

        if (requestParameters.includeFlattenedBodies !== undefined) {
            queryParameters['includeFlattenedBodies'] = requestParameters.includeFlattenedBodies;
        }

        if (requestParameters.includeApplications !== undefined) {
            queryParameters['includeApplications'] = requestParameters.includeApplications;
        }

        if (requestParameters.allowedApplicationMimeTypes !== undefined) {
            queryParameters['allowedApplicationMimeTypes'] = requestParameters.allowedApplicationMimeTypes;
        }

        if (requestParameters.includeCompositeParts !== undefined) {
            queryParameters['includeCompositeParts'] = requestParameters.includeCompositeParts;
        }

        if (requestParameters.includeFSTables !== undefined) {
            queryParameters['includeFSTables'] = requestParameters.includeFSTables;
        }

        if (requestParameters.includeFSComputedPartPropertyFunctions !== undefined) {
            queryParameters['includeFSComputedPartPropertyFunctions'] = requestParameters.includeFSComputedPartPropertyFunctions;
        }

        if (requestParameters.includeVariables !== undefined) {
            queryParameters['includeVariables'] = requestParameters.includeVariables;
        }

        if (requestParameters.includeVariableStudios !== undefined) {
            queryParameters['includeVariableStudios'] = requestParameters.includeVariableStudios;
        }

        if (requestParameters.allowedBlobExtensions !== undefined) {
            queryParameters['allowedBlobExtensions'] = requestParameters.allowedBlobExtensions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wv}/{wvid}/insertables`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wv"}}`, encodeURIComponent(String(requestParameters.wv))).replace(`{${"wvid"}}`, encodeURIComponent(String(requestParameters.wvid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTInsertablesListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve insertables by document ID and workspace or version ID.
     */
    async getInsertables(requestParameters: GetInsertablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTInsertablesListResponse> {
        const response = await this.getInsertablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve insertables by Query.
     */
    async getInsertablesQueryRaw(requestParameters: GetInsertablesQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTGlobalTreeNodeListResponse>> {
        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.q !== undefined) {
            queryParameters['q'] = requestParameters.q;
        }

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.owner !== undefined) {
            queryParameters['owner'] = requestParameters.owner;
        }

        if (requestParameters.getPathToRoot !== undefined) {
            queryParameters['getPathToRoot'] = requestParameters.getPathToRoot;
        }

        if (requestParameters.includeParts !== undefined) {
            queryParameters['includeParts'] = requestParameters.includeParts;
        }

        if (requestParameters.includeSurfaces !== undefined) {
            queryParameters['includeSurfaces'] = requestParameters.includeSurfaces;
        }

        if (requestParameters.includeSketches !== undefined) {
            queryParameters['includeSketches'] = requestParameters.includeSketches;
        }

        if (requestParameters.includeReferenceFeatures !== undefined) {
            queryParameters['includeReferenceFeatures'] = requestParameters.includeReferenceFeatures;
        }

        if (requestParameters.includeAssemblies !== undefined) {
            queryParameters['includeAssemblies'] = requestParameters.includeAssemblies;
        }

        if (requestParameters.includeFeatureStudios !== undefined) {
            queryParameters['includeFeatureStudios'] = requestParameters.includeFeatureStudios;
        }

        if (requestParameters.includeBlobs !== undefined) {
            queryParameters['includeBlobs'] = requestParameters.includeBlobs;
        }

        if (requestParameters.allowedBlobMimeTypes !== undefined) {
            queryParameters['allowedBlobMimeTypes'] = requestParameters.allowedBlobMimeTypes;
        }

        if (requestParameters.includePartStudios !== undefined) {
            queryParameters['includePartStudios'] = requestParameters.includePartStudios;
        }

        if (requestParameters.includeFeatures !== undefined) {
            queryParameters['includeFeatures'] = requestParameters.includeFeatures;
        }

        if (requestParameters.includeWires !== undefined) {
            queryParameters['includeWires'] = requestParameters.includeWires;
        }

        if (requestParameters.includeFlattenedBodies !== undefined) {
            queryParameters['includeFlattenedBodies'] = requestParameters.includeFlattenedBodies;
        }

        if (requestParameters.includeApplications !== undefined) {
            queryParameters['includeApplications'] = requestParameters.includeApplications;
        }

        if (requestParameters.allowedApplicationMimeTypes !== undefined) {
            queryParameters['allowedApplicationMimeTypes'] = requestParameters.allowedApplicationMimeTypes;
        }

        if (requestParameters.includeFSTables !== undefined) {
            queryParameters['includeFSTables'] = requestParameters.includeFSTables;
        }

        if (requestParameters.includeFSComputedPartPropertyFunctions !== undefined) {
            queryParameters['includeFSComputedPartPropertyFunctions'] = requestParameters.includeFSComputedPartPropertyFunctions;
        }

        if (requestParameters.includeVariables !== undefined) {
            queryParameters['includeVariables'] = requestParameters.includeVariables;
        }

        if (requestParameters.includeVariableStudios !== undefined) {
            queryParameters['includeVariableStudios'] = requestParameters.includeVariableStudios;
        }

        if (requestParameters.allowedBlobExtensions !== undefined) {
            queryParameters['allowedBlobExtensions'] = requestParameters.allowedBlobExtensions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/insertables`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTGlobalTreeNodeListResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve insertables by Query.
     */
    async getInsertablesQuery(requestParameters: GetInsertablesQueryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTGlobalTreeNodeListResponse> {
        const response = await this.getInsertablesQueryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the selected units and precision by document ID and workspace or version or microversion ID.
     */
    async getUnitInfoRaw(requestParameters: GetUnitInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTUnitInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getUnitInfo.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getUnitInfo.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getUnitInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/{wvm}/{wvmid}/unitinfo`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTUnitInfoFromJSON(jsonValue));
    }

    /**
     * Get the selected units and precision by document ID and workspace or version or microversion ID.
     */
    async getUnitInfo(requestParameters: GetUnitInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTUnitInfo> {
        const response = await this.getUnitInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve version by document ID and version ID.
     */
    async getVersionRaw(requestParameters: GetVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTVersionInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getVersion.');
        }

        if (requestParameters.vid === null || requestParameters.vid === undefined) {
            throw new runtime.RequiredError('vid','Required parameter requestParameters.vid was null or undefined when calling getVersion.');
        }

        const queryParameters: any = {};

        if (requestParameters.parents !== undefined) {
            queryParameters['parents'] = requestParameters.parents;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/versions/{vid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"vid"}}`, encodeURIComponent(String(requestParameters.vid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTVersionInfoFromJSON(jsonValue));
    }

    /**
     * Retrieve version by document ID and version ID.
     */
    async getVersion(requestParameters: GetVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTVersionInfo> {
        const response = await this.getVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Make a document public.
     */
    async makeDocumentPublicRaw(requestParameters: MakeDocumentPublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling makeDocumentPublic.');
        }

        if (requestParameters.bTACLPublicParams === null || requestParameters.bTACLPublicParams === undefined) {
            throw new runtime.RequiredError('bTACLPublicParams','Required parameter requestParameters.bTACLPublicParams was null or undefined when calling makeDocumentPublic.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/acl/public`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTACLPublicParamsToJSON(requestParameters.bTACLPublicParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Make a document public.
     */
    async makeDocumentPublic(requestParameters: MakeDocumentPublicRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.makeDocumentPublicRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge into workspace by document ID and workspace ID.
     */
    async mergeIntoWorkspaceRaw(requestParameters: MergeIntoWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentMergeInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling mergeIntoWorkspace.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling mergeIntoWorkspace.');
        }

        if (requestParameters.bTVersionOrWorkspaceMergeInfo === null || requestParameters.bTVersionOrWorkspaceMergeInfo === undefined) {
            throw new runtime.RequiredError('bTVersionOrWorkspaceMergeInfo','Required parameter requestParameters.bTVersionOrWorkspaceMergeInfo was null or undefined when calling mergeIntoWorkspace.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/workspaces/{wid}/merge`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTVersionOrWorkspaceMergeInfoToJSON(requestParameters.bTVersionOrWorkspaceMergeInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentMergeInfoFromJSON(jsonValue));
    }

    /**
     * Merge into workspace by document ID and workspace ID.
     */
    async mergeIntoWorkspace(requestParameters: MergeIntoWorkspaceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentMergeInfo> {
        const response = await this.mergeIntoWorkspaceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID
     */
    async mergePreviewRaw(requestParameters: MergePreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMergePreviewInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling mergePreview.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling mergePreview.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling mergePreview.');
        }

        if (requestParameters.sourceId === null || requestParameters.sourceId === undefined) {
            throw new runtime.RequiredError('sourceId','Required parameter requestParameters.sourceId was null or undefined when calling mergePreview.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.sourceType !== undefined) {
            queryParameters['sourceType'] = requestParameters.sourceType;
        }

        if (requestParameters.sourceId !== undefined) {
            queryParameters['sourceId'] = requestParameters.sourceId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/w/{wid}/mergePreview`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMergePreviewInfoFromJSON(jsonValue));
    }

    /**
     * Merge preview of changes that will occur based on document ID, workspace ID and source workspace/version ID
     */
    async mergePreview(requestParameters: MergePreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMergePreviewInfo> {
        const response = await this.mergePreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move tab by document ID and workspace ID.
     */
    async moveElementsToDocumentRaw(requestParameters: MoveElementsToDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMoveElementInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling moveElementsToDocument.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling moveElementsToDocument.');
        }

        if (requestParameters.bTMoveElementParams === null || requestParameters.bTMoveElementParams === undefined) {
            throw new runtime.RequiredError('bTMoveElementParams','Required parameter requestParameters.bTMoveElementParams was null or undefined when calling moveElementsToDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/moveelement`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTMoveElementParamsToJSON(requestParameters.bTMoveElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMoveElementInfoFromJSON(jsonValue));
    }

    /**
     * Move tab by document ID and workspace ID.
     */
    async moveElementsToDocument(requestParameters: MoveElementsToDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMoveElementInfo> {
        const response = await this.moveElementsToDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.
     */
    async restoreFromHistoryRaw(requestParameters: RestoreFromHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTRestoreFromHistoryInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.vm === null || requestParameters.vm === undefined) {
            throw new runtime.RequiredError('vm','Required parameter requestParameters.vm was null or undefined when calling restoreFromHistory.');
        }

        if (requestParameters.vmid === null || requestParameters.vmid === undefined) {
            throw new runtime.RequiredError('vmid','Required parameter requestParameters.vmid was null or undefined when calling restoreFromHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/w/{wid}/restore/{vm}/{vmid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"vm"}}`, encodeURIComponent(String(requestParameters.vm))).replace(`{${"vmid"}}`, encodeURIComponent(String(requestParameters.vmid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTRestoreInfoToJSON(requestParameters.bTRestoreInfo),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTRestoreFromHistoryInfoFromJSON(jsonValue));
    }

    /**
     * Restore version or microversion to workspace by document ID, workspace ID, and version or microversion ID.
     */
    async restoreFromHistory(requestParameters: RestoreFromHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTRestoreFromHistoryInfo> {
        const response = await this.restoreFromHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async revertUnchangedToRevisionsRaw(requestParameters: RevertUnchangedToRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTUnchangedElementInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling revertUnchangedToRevisions.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling revertUnchangedToRevisions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/revertunchangedtorevisions`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTRevertUnchangedParamsToJSON(requestParameters.bTRevertUnchangedParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTUnchangedElementInfoFromJSON));
    }

    /**
     */
    async revertUnchangedToRevisions(requestParameters: RevertUnchangedToRevisionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTUnchangedElementInfo>> {
        const response = await this.revertUnchangedToRevisionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This returns list of documents based on search parameters.
     * Search document.
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.bTDocumentSearchParams === null || requestParameters.bTDocumentSearchParams === undefined) {
            throw new runtime.RequiredError('bTDocumentSearchParams','Required parameter requestParameters.bTDocumentSearchParams was null or undefined when calling search.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentSearchParamsToJSON(requestParameters.bTDocumentSearchParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This returns list of documents based on search parameters.
     * Search document.
     */
    async search(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Share document by document ID.
     */
    async shareDocumentRaw(requestParameters: ShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTAclInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling shareDocument.');
        }

        if (requestParameters.bTShareParams === null || requestParameters.bTShareParams === undefined) {
            throw new runtime.RequiredError('bTShareParams','Required parameter requestParameters.bTShareParams was null or undefined when calling shareDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Share"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/share`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTShareParamsToJSON(requestParameters.bTShareParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTAclInfoFromJSON(jsonValue));
    }

    /**
     * Share document by document ID.
     */
    async shareDocument(requestParameters: ShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTAclInfo> {
        const response = await this.shareDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Share document by document ID with Onshape support.
     */
    async shareWithSupportRaw(requestParameters: ShareWithSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling shareWithSupport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/shareWithSupport`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Share document by document ID with Onshape support.
     */
    async shareWithSupport(requestParameters: ShareWithSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.shareWithSupportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async syncAppElementsRaw(requestParameters: SyncAppElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling syncAppElements.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling syncAppElements.');
        }

        if (requestParameters.bTSyncAppElementParams === null || requestParameters.bTSyncAppElementParams === undefined) {
            throw new runtime.RequiredError('bTSyncAppElementParams','Required parameter requestParameters.bTSyncAppElementParams was null or undefined when calling syncAppElements.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/syncAppElements`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTSyncAppElementParamsToJSON(requestParameters.bTSyncAppElementParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     */
    async syncAppElements(requestParameters: SyncAppElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.syncAppElementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Specify the ID of the entity to unshare with in the `eid` field, and specify the type of entity being identified in the `entryType` field. For example, to unshare a document with a company, you would use `1` as the `entryType` value and the `companyId` as the `entityId`.
     * Remove document View permissions from a user or other entity.
     */
    async unShareDocumentRaw(requestParameters: UnShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling unShareDocument.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling unShareDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.entryType !== undefined) {
            queryParameters['entryType'] = requestParameters.entryType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Share"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/share/{eid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Specify the ID of the entity to unshare with in the `eid` field, and specify the type of entity being identified in the `entryType` field. For example, to unshare a document with a company, you would use `1` as the `entryType` value and the `companyId` as the `entityId`.
     * Remove document View permissions from a user or other entity.
     */
    async unShareDocument(requestParameters: UnShareDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unShareDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unshare document with support.
     */
    async unshareFromSupportRaw(requestParameters: UnshareFromSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling unshareFromSupport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/shareWithSupport`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unshare document with support.
     */
    async unshareFromSupport(requestParameters: UnshareFromSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.unshareFromSupportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If anonymous access is allowed, you can allow or deny anonymous users the ability to export the document or publication. If `anonymousAccessAllowed=false` and `anonymousAllowsExport=true`, the call will throw an error.
     * Allow or deny anonymous access to a document or publication.
     */
    async updateAnonymousAccessRaw(requestParameters: UpdateAnonymousAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateAnonymousAccess.');
        }

        if (requestParameters.bTAclParams === null || requestParameters.bTAclParams === undefined) {
            throw new runtime.RequiredError('bTAclParams','Required parameter requestParameters.bTAclParams was null or undefined when calling updateAnonymousAccess.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read", "OAuth2Share"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}/acl/anonymousAccess`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTAclParamsToJSON(requestParameters.bTAclParams),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * If anonymous access is allowed, you can allow or deny anonymous users the ability to export the document or publication. If `anonymousAccessAllowed=false` and `anonymousAllowsExport=true`, the call will throw an error.
     * Allow or deny anonymous access to a document or publication.
     */
    async updateAnonymousAccess(requestParameters: UpdateAnonymousAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateAnonymousAccessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update document attributes by document ID.
     */
    async updateDocumentAttributesRaw(requestParameters: UpdateDocumentAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTDocumentSummaryInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateDocumentAttributes.');
        }

        if (requestParameters.bTDocumentParams === null || requestParameters.bTDocumentParams === undefined) {
            throw new runtime.RequiredError('bTDocumentParams','Required parameter requestParameters.bTDocumentParams was null or undefined when calling updateDocumentAttributes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/{did}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTDocumentParamsToJSON(requestParameters.bTDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTDocumentSummaryInfoFromJSON(jsonValue));
    }

    /**
     * Update document attributes by document ID.
     */
    async updateDocumentAttributes(requestParameters: UpdateDocumentAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTDocumentSummaryInfo> {
        const response = await this.updateDocumentAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update external references to latest by document ID, workspace ID, and tab ID.
     */
    async updateExternalReferencesToLatestDocumentsRaw(requestParameters: UpdateExternalReferencesToLatestDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTLinkToLatestDocumentInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        if (requestParameters.wid === null || requestParameters.wid === undefined) {
            throw new runtime.RequiredError('wid','Required parameter requestParameters.wid was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling updateExternalReferencesToLatestDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json;charset=UTF-8; qs=0.09';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Write"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wid"}}`, encodeURIComponent(String(requestParameters.wid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BTLinkToLatestDocumentParamsToJSON(requestParameters.bTLinkToLatestDocumentParams),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTLinkToLatestDocumentInfoFromJSON(jsonValue));
    }

    /**
     * Update external references to latest by document ID, workspace ID, and tab ID.
     */
    async updateExternalReferencesToLatestDocuments(requestParameters: UpdateExternalReferencesToLatestDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTLinkToLatestDocumentInfo> {
        const response = await this.updateExternalReferencesToLatestDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const Export2JsonWvEnum = {
    W: 'w',
    V: 'v'
} as const;
export type Export2JsonWvEnum = typeof Export2JsonWvEnum[keyof typeof Export2JsonWvEnum];
/**
 * @export
 */
export const GetElementsInDocumentWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetElementsInDocumentWvmEnum = typeof GetElementsInDocumentWvmEnum[keyof typeof GetElementsInDocumentWvmEnum];
/**
 * @export
 */
export const GetUnitInfoWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetUnitInfoWvmEnum = typeof GetUnitInfoWvmEnum[keyof typeof GetUnitInfoWvmEnum];
