/* tslint:disable */
/* eslint-disable */
/**
 * Onshape REST API
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn\'t used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.196.54436-927372740f35
 * Contact: api-support@onshape.zendesk.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BTBoundingBoxInfo,
  BTExportModelBodiesResponse734,
  BTExportTessellatedEdgesResponse327,
  BTExportTessellatedFacesResponse898,
  BTMassPropertiesBulkInfo,
  BTPartMetadataInfo,
  BTShadedViewsInfo,
  BTTableResponse1546,
  GlTF,
} from '../models';
import {
    BTBoundingBoxInfoFromJSON,
    BTBoundingBoxInfoToJSON,
    BTExportModelBodiesResponse734FromJSON,
    BTExportModelBodiesResponse734ToJSON,
    BTExportTessellatedEdgesResponse327FromJSON,
    BTExportTessellatedEdgesResponse327ToJSON,
    BTExportTessellatedFacesResponse898FromJSON,
    BTExportTessellatedFacesResponse898ToJSON,
    BTMassPropertiesBulkInfoFromJSON,
    BTMassPropertiesBulkInfoToJSON,
    BTPartMetadataInfoFromJSON,
    BTPartMetadataInfoToJSON,
    BTShadedViewsInfoFromJSON,
    BTShadedViewsInfoToJSON,
    BTTableResponse1546FromJSON,
    BTTableResponse1546ToJSON,
    GlTFFromJSON,
    GlTFToJSON,
} from '../models';

export interface ExportPSRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    partid: string;
    version?: string;
    _configuration?: string;
    linkDocumentId?: string;
}

export interface ExportPartGltfRequest {
    did: string;
    wvm: ExportPartGltfWvmEnum;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
    _configuration?: string;
    rollbackBarIndex?: number;
    elementMicroversionId?: string;
    angleTolerance?: number;
    chordTolerance?: number;
    precomputedLevelOfDetail?: string;
    outputSeparateFaceNodes?: boolean;
    faceId?: Array<string>;
    outputFaceAppearances?: boolean;
    maxFacetWidth?: number;
}

export interface ExportStlRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    partid: string;
    mode?: string;
    grouping?: boolean;
    scale?: number;
    units?: string;
    angleTolerance?: number;
    chordTolerance?: number;
    maxFacetWidth?: number;
    minFacetWidth?: number;
    _configuration?: string;
    linkDocumentId?: string;
}

export interface GetBendTableRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
}

export interface GetBodyDetailsRequest {
    did: string;
    wvm: GetBodyDetailsWvmEnum;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
    _configuration?: string;
    rollbackBarIndex?: number;
    elementMicroversionId?: string;
    includeGeometricData?: boolean;
}

export interface GetBoundingBoxesRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    partid: string;
    includeHidden?: boolean;
    _configuration?: string;
    linkDocumentId?: string;
}

export interface GetEdgesRequest {
    did: string;
    wvm: GetEdgesWvmEnum;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
    _configuration?: string;
    rollbackBarIndex?: number;
    elementMicroversionId?: string;
    angleTolerance?: number;
    chordTolerance?: number;
    precomputedLevelOfDetail?: string;
    edgeId?: Array<string>;
}

export interface GetFaces1Request {
    did: string;
    wvm: GetFaces1WvmEnum;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
    _configuration?: string;
    rollbackBarIndex?: number;
    elementMicroversionId?: string;
    angleTolerance?: number;
    chordTolerance?: number;
    precomputedLevelOfDetail?: string;
    faceId?: Array<string>;
    outputFaceAppearances?: boolean;
    maxFacetWidth?: number;
    outputVertexNormals?: boolean;
    outputFacetNormals?: boolean;
    outputTextureCoordinates?: boolean;
    outputIndexTable?: boolean;
    outputErrorFaces?: boolean;
    combineCompositePartConstituents?: boolean;
}

export interface GetMassPropertiesRequest {
    did: string;
    wvm: GetMassPropertiesWvmEnum;
    wvmid: string;
    eid: string;
    partid: string;
    linkDocumentId?: string;
    _configuration?: string;
    rollbackBarIndex?: number;
    elementMicroversionId?: string;
    inferMetadataOwner?: boolean;
    useMassPropertyOverrides?: boolean;
}

export interface GetPartShadedViewsRequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    partid: string;
    viewMatrix?: string;
    outputHeight?: number;
    outputWidth?: number;
    pixelSize?: number;
    edges?: string;
    useAntiAliasing?: boolean;
    _configuration?: string;
    linkDocumentId?: string;
}

export interface GetPartsWMVRequest {
    did: string;
    wvm: GetPartsWMVWvmEnum;
    wvmid: string;
    elementId: string;
    linkDocumentId?: string;
    _configuration?: string;
    withThumbnails?: boolean;
    includePropertyDefaults?: boolean;
    includeFlatParts?: boolean;
}

export interface GetPartsWMVERequest {
    did: string;
    wvm: string;
    wvmid: string;
    eid: string;
    withThumbnails?: boolean;
    includePropertyDefaults?: boolean;
    includeFlatParts?: boolean;
    _configuration?: string;
    linkDocumentId?: string;
}

/**
 * 
 */
export class PartApi extends runtime.BaseAPI {

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as a Parasolid file.
     */
    async exportPSRaw(requestParameters: ExportPSRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling exportPS.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling exportPS.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling exportPS.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling exportPS.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling exportPS.');
        }

        const queryParameters: any = {};

        if (requestParameters.version !== undefined) {
            queryParameters['version'] = requestParameters.version;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/parasolid`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as a Parasolid file.
     */
    async exportPS(requestParameters: ExportPSRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.exportPSRaw(requestParameters, initOverrides);
    }

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as a glTF file.
     */
    async exportPartGltfRaw(requestParameters: ExportPartGltfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GlTF>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling exportPartGltf.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling exportPartGltf.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling exportPartGltf.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling exportPartGltf.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling exportPartGltf.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.rollbackBarIndex !== undefined) {
            queryParameters['rollbackBarIndex'] = requestParameters.rollbackBarIndex;
        }

        if (requestParameters.elementMicroversionId !== undefined) {
            queryParameters['elementMicroversionId'] = requestParameters.elementMicroversionId;
        }

        if (requestParameters.angleTolerance !== undefined) {
            queryParameters['angleTolerance'] = requestParameters.angleTolerance;
        }

        if (requestParameters.chordTolerance !== undefined) {
            queryParameters['chordTolerance'] = requestParameters.chordTolerance;
        }

        if (requestParameters.precomputedLevelOfDetail !== undefined) {
            queryParameters['precomputedLevelOfDetail'] = requestParameters.precomputedLevelOfDetail;
        }

        if (requestParameters.outputSeparateFaceNodes !== undefined) {
            queryParameters['outputSeparateFaceNodes'] = requestParameters.outputSeparateFaceNodes;
        }

        if (requestParameters.faceId) {
            queryParameters['faceId'] = requestParameters.faceId;
        }

        if (requestParameters.outputFaceAppearances !== undefined) {
            queryParameters['outputFaceAppearances'] = requestParameters.outputFaceAppearances;
        }

        if (requestParameters.maxFacetWidth !== undefined) {
            queryParameters['maxFacetWidth'] = requestParameters.maxFacetWidth;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/gltf`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GlTFFromJSON(jsonValue));
    }

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as a glTF file.
     */
    async exportPartGltf(requestParameters: ExportPartGltfRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GlTF> {
        const response = await this.exportPartGltfRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as an STL file.
     */
    async exportStlRaw(requestParameters: ExportStlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling exportStl.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling exportStl.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling exportStl.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling exportStl.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling exportStl.');
        }

        const queryParameters: any = {};

        if (requestParameters.mode !== undefined) {
            queryParameters['mode'] = requestParameters.mode;
        }

        if (requestParameters.grouping !== undefined) {
            queryParameters['grouping'] = requestParameters.grouping;
        }

        if (requestParameters.scale !== undefined) {
            queryParameters['scale'] = requestParameters.scale;
        }

        if (requestParameters.units !== undefined) {
            queryParameters['units'] = requestParameters.units;
        }

        if (requestParameters.angleTolerance !== undefined) {
            queryParameters['angleTolerance'] = requestParameters.angleTolerance;
        }

        if (requestParameters.chordTolerance !== undefined) {
            queryParameters['chordTolerance'] = requestParameters.chordTolerance;
        }

        if (requestParameters.maxFacetWidth !== undefined) {
            queryParameters['maxFacetWidth'] = requestParameters.maxFacetWidth;
        }

        if (requestParameters.minFacetWidth !== undefined) {
            queryParameters['minFacetWidth'] = requestParameters.minFacetWidth;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/stl`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a 307 redirect from which to download the exported file. See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
     * Export a part as an STL file.
     */
    async exportStl(requestParameters: ExportStlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.exportStlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a part\'s sheet metal bend table.
     */
    async getBendTableRaw(requestParameters: GetBendTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTTableResponse1546>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getBendTable.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getBendTable.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getBendTable.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getBendTable.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getBendTable.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/sheetmetal/bendtable`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTTableResponse1546FromJSON(jsonValue));
    }

    /**
     * Get a part\'s sheet metal bend table.
     */
    async getBendTable(requestParameters: GetBendTableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTTableResponse1546> {
        const response = await this.getBendTableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * All coordinates are in meters (m).
     * Get a part\'s body details.
     */
    async getBodyDetailsRaw(requestParameters: GetBodyDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTExportModelBodiesResponse734>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getBodyDetails.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getBodyDetails.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getBodyDetails.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getBodyDetails.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getBodyDetails.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.rollbackBarIndex !== undefined) {
            queryParameters['rollbackBarIndex'] = requestParameters.rollbackBarIndex;
        }

        if (requestParameters.elementMicroversionId !== undefined) {
            queryParameters['elementMicroversionId'] = requestParameters.elementMicroversionId;
        }

        if (requestParameters.includeGeometricData !== undefined) {
            queryParameters['includeGeometricData'] = requestParameters.includeGeometricData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/bodydetails`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTExportModelBodiesResponse734FromJSON(jsonValue));
    }

    /**
     * All coordinates are in meters (m).
     * Get a part\'s body details.
     */
    async getBodyDetails(requestParameters: GetBodyDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTExportModelBodiesResponse734> {
        const response = await this.getBodyDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a part\'s bounding box details.
     */
    async getBoundingBoxesRaw(requestParameters: GetBoundingBoxesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTBoundingBoxInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getBoundingBoxes.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getBoundingBoxes.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getBoundingBoxes.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getBoundingBoxes.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getBoundingBoxes.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeHidden !== undefined) {
            queryParameters['includeHidden'] = requestParameters.includeHidden;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/boundingboxes`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTBoundingBoxInfoFromJSON(jsonValue));
    }

    /**
     * Get a part\'s bounding box details.
     */
    async getBoundingBoxes(requestParameters: GetBoundingBoxesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTBoundingBoxInfo> {
        const response = await this.getBoundingBoxesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the coordinates (in meters) of each edge\'s endpoints.
     * Get a list of a part\'s tessellation edges.
     */
    async getEdgesRaw(requestParameters: GetEdgesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTExportTessellatedEdgesResponse327>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getEdges.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getEdges.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getEdges.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getEdges.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getEdges.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.rollbackBarIndex !== undefined) {
            queryParameters['rollbackBarIndex'] = requestParameters.rollbackBarIndex;
        }

        if (requestParameters.elementMicroversionId !== undefined) {
            queryParameters['elementMicroversionId'] = requestParameters.elementMicroversionId;
        }

        if (requestParameters.angleTolerance !== undefined) {
            queryParameters['angleTolerance'] = requestParameters.angleTolerance;
        }

        if (requestParameters.chordTolerance !== undefined) {
            queryParameters['chordTolerance'] = requestParameters.chordTolerance;
        }

        if (requestParameters.precomputedLevelOfDetail !== undefined) {
            queryParameters['precomputedLevelOfDetail'] = requestParameters.precomputedLevelOfDetail;
        }

        if (requestParameters.edgeId) {
            queryParameters['edgeId'] = requestParameters.edgeId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatededges`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTExportTessellatedEdgesResponse327FromJSON(jsonValue));
    }

    /**
     * Returns the coordinates (in meters) of each edge\'s endpoints.
     * Get a list of a part\'s tessellation edges.
     */
    async getEdges(requestParameters: GetEdgesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTExportTessellatedEdgesResponse327> {
        const response = await this.getEdgesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Coordinates are in meters (m).
     * Get a list of a part\'s tessellation faces.
     */
    async getFaces1Raw(requestParameters: GetFaces1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTExportTessellatedFacesResponse898>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getFaces1.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getFaces1.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getFaces1.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getFaces1.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getFaces1.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.rollbackBarIndex !== undefined) {
            queryParameters['rollbackBarIndex'] = requestParameters.rollbackBarIndex;
        }

        if (requestParameters.elementMicroversionId !== undefined) {
            queryParameters['elementMicroversionId'] = requestParameters.elementMicroversionId;
        }

        if (requestParameters.angleTolerance !== undefined) {
            queryParameters['angleTolerance'] = requestParameters.angleTolerance;
        }

        if (requestParameters.chordTolerance !== undefined) {
            queryParameters['chordTolerance'] = requestParameters.chordTolerance;
        }

        if (requestParameters.precomputedLevelOfDetail !== undefined) {
            queryParameters['precomputedLevelOfDetail'] = requestParameters.precomputedLevelOfDetail;
        }

        if (requestParameters.faceId) {
            queryParameters['faceId'] = requestParameters.faceId;
        }

        if (requestParameters.outputFaceAppearances !== undefined) {
            queryParameters['outputFaceAppearances'] = requestParameters.outputFaceAppearances;
        }

        if (requestParameters.maxFacetWidth !== undefined) {
            queryParameters['maxFacetWidth'] = requestParameters.maxFacetWidth;
        }

        if (requestParameters.outputVertexNormals !== undefined) {
            queryParameters['outputVertexNormals'] = requestParameters.outputVertexNormals;
        }

        if (requestParameters.outputFacetNormals !== undefined) {
            queryParameters['outputFacetNormals'] = requestParameters.outputFacetNormals;
        }

        if (requestParameters.outputTextureCoordinates !== undefined) {
            queryParameters['outputTextureCoordinates'] = requestParameters.outputTextureCoordinates;
        }

        if (requestParameters.outputIndexTable !== undefined) {
            queryParameters['outputIndexTable'] = requestParameters.outputIndexTable;
        }

        if (requestParameters.outputErrorFaces !== undefined) {
            queryParameters['outputErrorFaces'] = requestParameters.outputErrorFaces;
        }

        if (requestParameters.combineCompositePartConstituents !== undefined) {
            queryParameters['combineCompositePartConstituents'] = requestParameters.combineCompositePartConstituents;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatedfaces`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTExportTessellatedFacesResponse898FromJSON(jsonValue));
    }

    /**
     * Coordinates are in meters (m).
     * Get a list of a part\'s tessellation faces.
     */
    async getFaces1(requestParameters: GetFaces1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTExportTessellatedFacesResponse898> {
        const response = await this.getFaces1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).  When three values are returned:   * The first is the calculated value.   * The second is the minimum possible value, considering tolerance.   * The third is the maximum possible value, considering tolerance.
     * Get a part\'s mass properties.
     */
    async getMassPropertiesRaw(requestParameters: GetMassPropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTMassPropertiesBulkInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getMassProperties.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getMassProperties.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getMassProperties.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getMassProperties.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getMassProperties.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.rollbackBarIndex !== undefined) {
            queryParameters['rollbackBarIndex'] = requestParameters.rollbackBarIndex;
        }

        if (requestParameters.elementMicroversionId !== undefined) {
            queryParameters['elementMicroversionId'] = requestParameters.elementMicroversionId;
        }

        if (requestParameters.inferMetadataOwner !== undefined) {
            queryParameters['inferMetadataOwner'] = requestParameters.inferMetadataOwner;
        }

        if (requestParameters.useMassPropertyOverrides !== undefined) {
            queryParameters['useMassPropertyOverrides'] = requestParameters.useMassPropertyOverrides;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/massproperties`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTMassPropertiesBulkInfoFromJSON(jsonValue));
    }

    /**
     * Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).  When three values are returned:   * The first is the calculated value.   * The second is the minimum possible value, considering tolerance.   * The third is the maximum possible value, considering tolerance.
     * Get a part\'s mass properties.
     */
    async getMassProperties(requestParameters: GetMassPropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTMassPropertiesBulkInfo> {
        const response = await this.getMassPropertiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a part\'s shaded views.
     */
    async getPartShadedViewsRaw(requestParameters: GetPartShadedViewsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BTShadedViewsInfo>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getPartShadedViews.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getPartShadedViews.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getPartShadedViews.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getPartShadedViews.');
        }

        if (requestParameters.partid === null || requestParameters.partid === undefined) {
            throw new runtime.RequiredError('partid','Required parameter requestParameters.partid was null or undefined when calling getPartShadedViews.');
        }

        const queryParameters: any = {};

        if (requestParameters.viewMatrix !== undefined) {
            queryParameters['viewMatrix'] = requestParameters.viewMatrix;
        }

        if (requestParameters.outputHeight !== undefined) {
            queryParameters['outputHeight'] = requestParameters.outputHeight;
        }

        if (requestParameters.outputWidth !== undefined) {
            queryParameters['outputWidth'] = requestParameters.outputWidth;
        }

        if (requestParameters.pixelSize !== undefined) {
            queryParameters['pixelSize'] = requestParameters.pixelSize;
        }

        if (requestParameters.edges !== undefined) {
            queryParameters['edges'] = requestParameters.edges;
        }

        if (requestParameters.useAntiAliasing !== undefined) {
            queryParameters['useAntiAliasing'] = requestParameters.useAntiAliasing;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/shadedviews`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))).replace(`{${"partid"}}`, encodeURIComponent(String(requestParameters.partid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BTShadedViewsInfoFromJSON(jsonValue));
    }

    /**
     * Get a part\'s shaded views.
     */
    async getPartShadedViews(requestParameters: GetPartShadedViewsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BTShadedViewsInfo> {
        const response = await this.getPartShadedViewsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all parts in a workspace, version, or microversion.
     */
    async getPartsWMVRaw(requestParameters: GetPartsWMVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTPartMetadataInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getPartsWMV.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getPartsWMV.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getPartsWMV.');
        }

        if (requestParameters.elementId === null || requestParameters.elementId === undefined) {
            throw new runtime.RequiredError('elementId','Required parameter requestParameters.elementId was null or undefined when calling getPartsWMV.');
        }

        const queryParameters: any = {};

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        if (requestParameters.elementId !== undefined) {
            queryParameters['elementId'] = requestParameters.elementId;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.withThumbnails !== undefined) {
            queryParameters['withThumbnails'] = requestParameters.withThumbnails;
        }

        if (requestParameters.includePropertyDefaults !== undefined) {
            queryParameters['includePropertyDefaults'] = requestParameters.includePropertyDefaults;
        }

        if (requestParameters.includeFlatParts !== undefined) {
            queryParameters['includeFlatParts'] = requestParameters.includeFlatParts;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTPartMetadataInfoFromJSON));
    }

    /**
     * Get all parts in a workspace, version, or microversion.
     */
    async getPartsWMV(requestParameters: GetPartsWMVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTPartMetadataInfo>> {
        const response = await this.getPartsWMVRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all parts in an element.
     */
    async getPartsWMVERaw(requestParameters: GetPartsWMVERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BTPartMetadataInfo>>> {
        if (requestParameters.did === null || requestParameters.did === undefined) {
            throw new runtime.RequiredError('did','Required parameter requestParameters.did was null or undefined when calling getPartsWMVE.');
        }

        if (requestParameters.wvm === null || requestParameters.wvm === undefined) {
            throw new runtime.RequiredError('wvm','Required parameter requestParameters.wvm was null or undefined when calling getPartsWMVE.');
        }

        if (requestParameters.wvmid === null || requestParameters.wvmid === undefined) {
            throw new runtime.RequiredError('wvmid','Required parameter requestParameters.wvmid was null or undefined when calling getPartsWMVE.');
        }

        if (requestParameters.eid === null || requestParameters.eid === undefined) {
            throw new runtime.RequiredError('eid','Required parameter requestParameters.eid was null or undefined when calling getPartsWMVE.');
        }

        const queryParameters: any = {};

        if (requestParameters.withThumbnails !== undefined) {
            queryParameters['withThumbnails'] = requestParameters.withThumbnails;
        }

        if (requestParameters.includePropertyDefaults !== undefined) {
            queryParameters['includePropertyDefaults'] = requestParameters.includePropertyDefaults;
        }

        if (requestParameters.includeFlatParts !== undefined) {
            queryParameters['includeFlatParts'] = requestParameters.includeFlatParts;
        }

        if (requestParameters._configuration !== undefined) {
            queryParameters['configuration'] = requestParameters._configuration;
        }

        if (requestParameters.linkDocumentId !== undefined) {
            queryParameters['linkDocumentId'] = requestParameters.linkDocumentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["OAuth2Read"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/parts/d/{did}/{wvm}/{wvmid}/e/{eid}`.replace(`{${"did"}}`, encodeURIComponent(String(requestParameters.did))).replace(`{${"wvm"}}`, encodeURIComponent(String(requestParameters.wvm))).replace(`{${"wvmid"}}`, encodeURIComponent(String(requestParameters.wvmid))).replace(`{${"eid"}}`, encodeURIComponent(String(requestParameters.eid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BTPartMetadataInfoFromJSON));
    }

    /**
     * Get all parts in an element.
     */
    async getPartsWMVE(requestParameters: GetPartsWMVERequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BTPartMetadataInfo>> {
        const response = await this.getPartsWMVERaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportPartGltfWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type ExportPartGltfWvmEnum = typeof ExportPartGltfWvmEnum[keyof typeof ExportPartGltfWvmEnum];
/**
 * @export
 */
export const GetBodyDetailsWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetBodyDetailsWvmEnum = typeof GetBodyDetailsWvmEnum[keyof typeof GetBodyDetailsWvmEnum];
/**
 * @export
 */
export const GetEdgesWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetEdgesWvmEnum = typeof GetEdgesWvmEnum[keyof typeof GetEdgesWvmEnum];
/**
 * @export
 */
export const GetFaces1WvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetFaces1WvmEnum = typeof GetFaces1WvmEnum[keyof typeof GetFaces1WvmEnum];
/**
 * @export
 */
export const GetMassPropertiesWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetMassPropertiesWvmEnum = typeof GetMassPropertiesWvmEnum[keyof typeof GetMassPropertiesWvmEnum];
/**
 * @export
 */
export const GetPartsWMVWvmEnum = {
    W: 'w',
    V: 'v',
    M: 'm'
} as const;
export type GetPartsWMVWvmEnum = typeof GetPartsWMVWvmEnum[keyof typeof GetPartsWMVWvmEnum];
